<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小虎 - Mechanical student,Robot enthusiast</title>
    <link>https://littlethinking.cn/</link>
    <description>Recent content on 小虎 - Mechanical student,Robot enthusiast</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 17 Jan 2022 12:01:23 +0800</lastBuildDate>
    
        <atom:link href="https://littlethinking.cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>【LeetCode题解】6、Z字形变换</title>
      <link>https://littlethinking.cn/post/leetcode%E9%A2%98%E8%A7%A3/leetcode%E9%A2%98%E8%A7%A36z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</link>
      <pubDate>Mon, 17 Jan 2022 12:01:23 +0800</pubDate>
      
      <guid>https://littlethinking.cn/post/leetcode%E9%A2%98%E8%A7%A3/leetcode%E9%A2%98%E8%A7%A36z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</guid>
      
        <description>&lt;h2 id=&#34;1-题目&#34;&gt;1 题目&lt;/h2&gt;
&lt;p&gt;将一个给定字符串&lt;code&gt; s&lt;/code&gt; 根据给定的行数 &lt;code&gt;numRows&lt;/code&gt; ，以从上往下、从左到右进行 Z 字形排列。&lt;/p&gt;
&lt;p&gt;比如输入字符串为 &lt;code&gt;&amp;quot;PAYPALISHIRING&amp;quot;&lt;/code&gt; 行数为 3 时，排列如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;P   A   H   N
A P L S I I G
Y   I   R
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&lt;code&gt;&amp;quot;PAHNAPLSIIGYIR&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;请你实现这个将字符串进行指定行数变换的函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;convert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;numRows&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;2-解题&#34;&gt;2 解题&lt;/h2&gt;
&lt;h3 id=&#34;21-按行排序&#34;&gt;2.1 按行排序&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过从左向右迭代字符串，我们可以轻松地确定字符位于 Z 字形图案中的哪一行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用 min(numRows,len(&lt;em&gt;s&lt;/em&gt;)) 个列表来表示 Z 字形图案中的非空行。&lt;/p&gt;
&lt;p&gt;从左到右迭代 s，将每个字符添加到合适的行。可以使用当前行和当前方向这两个变量对合适的行进行跟踪。&lt;/p&gt;
&lt;p&gt;只有当我们&lt;strong&gt;向上移动到最上面的行或向下移动到最下面的行&lt;/strong&gt;时，当前方向才会发生改变。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;convert_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;numRows&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;numRows&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//新增一个存储string的容器，用于存储每一行的字符串
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rows&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;numRows&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())));&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;curRow&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//当前行号
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;goingDown&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//行的增加方向
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;rows&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;curRow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;//判断是否是最上面的行还是最下边的行，
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;//若是，改变方向
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;curRow&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;curRow&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;numRows&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;goingDown&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;goingDown&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;//根据当前方向判断行号
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;curRow&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;goingDown&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//各个行的string加起来，得到返回的字符串
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;row&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rows&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;row&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时间复杂度：$O(n)$,其中 n 是字符串的长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空间复杂度：$O(n)$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-按行访问&#34;&gt;2.2 按行访问&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按照与逐行读取 Z 字形图案相同的顺序访问字符串，&lt;strong&gt;关键寻找数学规律&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先访问 &lt;code&gt;行 0&lt;/code&gt; 中的所有字符，接着访问 &lt;code&gt;行 1&lt;/code&gt;，然后 &lt;code&gt;行 2&lt;/code&gt;，依此类推&amp;hellip;&lt;/p&gt;
&lt;p&gt;对于所有整数 k，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;行 0 中的字符位于索引 k (2 ⋅ numRows − 2) 处，&lt;strong&gt;k表示该行的的几个字符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;行 numRows − 1 中的字符位于索引 k (2 ⋅ numRows − 2) + numRows − 1 处;&lt;/li&gt;
&lt;li&gt;内部的 行 i 中的字符位于索引 k (2 ⋅ numRows − 2) + i 以及 (k + 1)(2 ⋅ numRows − 2) − i 处。（注：会比第0与第numRows-1多一个）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;convert_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;numRows&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;

    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;numRows&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cycleLen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;numRows&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;numRows&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;cm&#34;&gt;/*leetcode 官网写法
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;        for (int j = 0; j + i &amp;lt; n; j += cycleLen) 
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;        {
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;        	//最上面的行与最下边的行，情况1、2以及3的第一个情况
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;            ret += s[j + i];
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;            //中间的行，3的第二种情况
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;            if (i != 0 &amp;amp;&amp;amp; i != numRows - 1 &amp;amp;&amp;amp; j + cycleLen - i &amp;lt; n)
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;                ret += s[j + cycleLen - i];
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;        }
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;        */&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;//分析
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;//pos索引下标
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;//第0行
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cycleLen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cycleLen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;//i=0
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;c1&#34;&gt;//可改写为pos=k*cycleLen + i
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;numRows&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cycleLen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cycleLen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;numRows&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; 
                &lt;span class=&#34;c1&#34;&gt;//其中numRows - 1即为i
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;c1&#34;&gt;//可改写为pos=k*cycleLen + i
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cycleLen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;//第一个数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;//第二个数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;               &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cycleLen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
                   &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
                
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;//三种情况简化即为官网类似的代码
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时间复杂度：$O(n)$,其中 n 是字符串的长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空间复杂度：$O(n)$，在C++中，如果返回字符串不被视为额外空间，则复杂度为$O(1)$。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>【LeetCode题解】5、最长回文子串</title>
      <link>https://littlethinking.cn/post/leetcode%E9%A2%98%E8%A7%A3/leetcode%E9%A2%98%E8%A7%A35%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Tue, 11 Jan 2022 12:01:23 +0800</pubDate>
      
      <guid>https://littlethinking.cn/post/leetcode%E9%A2%98%E8%A7%A3/leetcode%E9%A2%98%E8%A7%A35%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</guid>
      
        <description>&lt;h2 id=&#34;1-题目&#34;&gt;1 题目&lt;/h2&gt;
&lt;p&gt;给定一个字符串 &lt;strong&gt;s&lt;/strong&gt;，找到 &lt;strong&gt;s&lt;/strong&gt; 中最长的回文子串。你可以假设 &lt;strong&gt;s&lt;/strong&gt; 的最大长度为1000。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;输入: &amp;#34;babad&amp;#34;
输出: &amp;#34;bab&amp;#34;
注意: &amp;#34;aba&amp;#34; 也是一个有效答案。
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;示例2&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;输入: &amp;#34;cbbd&amp;#34;
输出: &amp;#34;bb&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;2-解题&#34;&gt;2 解题&lt;/h2&gt;
&lt;h3 id=&#34;21-动态规划&#34;&gt;2.1 动态规划&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串 “ababa”，如果我们已经知道 “bab” 是回文串，那么“ababa” 一定是回文串，这是因为它的首尾两个字母都是“a”。&lt;/p&gt;
&lt;p&gt;根据这样的思路，我们就可以用动态规划的方法解决本题。我们用 P(i,j) 表示字符串 s 的第 i 到 j 个字母组成的串（下文表示成s[i:j]）是否为回文串&lt;/p&gt;
&lt;p&gt;$$
P(i,j) =   \begin{cases}
&amp;amp; true \ \ 如果字串S_i&amp;hellip;S_j是回文串\\&lt;br&gt;
&amp;amp; false \ 其他情况
\end{cases}
$$
这里的「其它情况」包含两种可能性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;s&lt;/em&gt;[&lt;em&gt;i&lt;/em&gt;,&lt;em&gt;j&lt;/em&gt;] 本身不是一个回文串;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;i&lt;/em&gt;&amp;gt;&lt;em&gt;j&lt;/em&gt;，此时 s[i,j] 本身不合法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么我们就可以写出动态规划的状态转移方程：
$$
P(i,j) = P(i+1,j-1) \land (S_i == S_j)
$$
也就是说，只有 s[i+1:j−1] 是回文串，并且 s 的第 i和 j 个字母相同时，s[i:j] 才会是回文串。&lt;/p&gt;
&lt;p&gt;上文的所有讨论是建立在子串长度大于 2 的前提之上的，我们还需要考虑动态规划中的边界条件，即子串的长度为 1 或 2。对于长度为 1 的子串，它显然是个回文串；对于长度为 2 的子串，只要它的两个字母相同，它就是一个回文串。因此我们就可以写出动态规划的边界条件：
$$
\begin{cases}
&amp;amp;P(i,j) = true\\&lt;br&gt;
&amp;amp;P(i,i+1)=(S_i==S_{i+1})
\end{cases}
$$
根据这个思路，我们就可以完成动态规划了，最终的答案即为所有$ P(i, j) = {true}$ 中 j−i+1（即子串长度）的最大值。**注意：在状态转移方程中，我们是从长度较短的字符串向长度较长的字符串进行转移的，因此一定要注意动态规划的循环顺序。**&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;longestPalindrome&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//字符串为空或者长度为1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxLen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// dp[i][j] 表示 s[i..j] 是否是回文串
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 二维数组表征
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 初始化：所有长度为 1 的子串都是回文串
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 递推开始
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 先枚举子串长度，L表示子串长度
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;L&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;L&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 枚举左边界，左边界的上限设置可以宽松一些
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
            &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;L&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// 如果右边界越界，就可以退出当前循环
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
                &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; 
                &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; 
                &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; 
                &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;c1&#34;&gt;//长度小于等于3，边界条件
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
                    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                        &lt;span class=&#34;n&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
                    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; 
                    &lt;span class=&#34;c1&#34;&gt;//状态转移方程
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; 
                    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                        &lt;span class=&#34;n&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
                    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

                &lt;span class=&#34;c1&#34;&gt;// 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;c1&#34;&gt;//判断此时的长度是否最长，若是记录回文长度和起始位置
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxLen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
                &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;maxLen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;substr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxLen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//该函数的意思是获取从begin开始长度为maxlen长度的字符串
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时间复杂度：$O(n^2)$,其中 n 是字符串的长度。动态规划的状态总数
$O(n^2)$，对于每个状态，我们需要转移的时间为 $O(1)$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空间复杂度：$O(n^2)$，即存储动态规划状态需要的空间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-中心扩展算法&#34;&gt;2.2 中心扩展算法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.1中的状态转移方程：
$$
\begin{cases}
&amp;amp;P(i,j) = true\\&lt;br&gt;
&amp;amp;P(i,i+1)=(S_i==S_{i+1}) \\&lt;br&gt;
&amp;amp;P(i,j) = P(i+1,j-1)  \land (S_i == S_j)
\end{cases}
$$
找出其中的状态转移链：
$$
P(i,j) \leftarrow P(i+1,j-1) \leftarrow P(i+2,j-2) \leftarrow&amp;hellip;\leftarrow 某一边界条件
$$
可以发现，**所有的状态在转移的时候的可能性都是唯一的**。也就是说，我们可以从每一种边界情况开始「扩展」，也可以得出所有的状态对应的答案。&lt;/p&gt;
&lt;p&gt;边界情况即为子串长度为 1 或 2 的情况。我们枚举每一种边界情况，并从对应的子串开始不断地向两边扩展。如果两边的字母相同，我们就可以继续扩展，例如从 &lt;code&gt;P(i+1,j-1)&lt;/code&gt; 扩展到 &lt;code&gt;P(i,j)&lt;/code&gt;；如果两边的字母不同，我们就可以停止扩展，因为在这之后的子串都不能是回文串了。&lt;/p&gt;
&lt;p&gt;我们可以发现，「边界情况」对应的子串实际上就是我们「扩展」出的回文串的「回文中心」。方法二的本质即为：我们枚举所有的「回文中心」并尝试「扩展」，直到无法扩展为止，此时的回文串长度即为此「回文中心」下的最长回文串长度。我们对所有的长度求出最大值，即可得到最终的答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;longestPalindrome&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;end&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//以第i个位置为中心或者i，i+1（偶数回文，且i与i+1字符一致）两个为中心
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;expandAroundCenter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;expandAroundCenter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;len1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;end&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//从i位置向分别向左或是向右扩展len/2个长度
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;//若len为奇数，分别向左向右扩展（len-1）/2
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;//若len为偶数，向左扩展len/2 - 1，向右扩展len/2
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;//其中len为奇时，（len-1）/2 与 len/2值一样
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;//len为偶时，len/2 - 1 与（len-1）/2值一样
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;//故向左（len-1）/2，向右len/2
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;start&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;end&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;substr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;end&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;expandAroundCenter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;L&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;R&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;R&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//若是（i,i）传进来，多计算了一次L--与R++
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//此时相当于左边下标等于L+1，右边下标等于R-1，
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//长度为R-1-（L+1）+1=R-L-1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//同理若（i，i+1）起始是回文也是一样的，多计算了一次
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//若不是的话，返回值为0
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;R&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;L&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时间复杂度：$O(n^2)$。&lt;/p&gt;
&lt;p&gt;其中 n 是字符串的长度。长度为 1 和 2 的回文中心分别有 n 和 n−1 个，每个回文中心最多会向外扩展 $O(n)$次。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空间复杂度:$O(1)$。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>【LeetCode题解】4、寻找两个有序数组的中位数</title>
      <link>https://littlethinking.cn/post/leetcode%E9%A2%98%E8%A7%A3/leetcode%E9%A2%98%E8%A7%A34%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Mon, 10 Jan 2022 12:01:23 +0800</pubDate>
      
      <guid>https://littlethinking.cn/post/leetcode%E9%A2%98%E8%A7%A3/leetcode%E9%A2%98%E8%A7%A34%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid>
      
        <description>&lt;h2 id=&#34;1-题目&#34;&gt;1 题目&lt;/h2&gt;
&lt;p&gt;给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。&lt;/p&gt;
&lt;p&gt;算法的时间复杂度应该为 O(log (m+n)) 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;示例2&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;示例3&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;输入：nums1 = [0,0], nums2 = [0,0]
输出：0.00000
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;示例4&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;输入：nums1 = [], nums2 = [1]
输出：1.00000
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;2-解题&#34;&gt;2 解题&lt;/h2&gt;
&lt;h3 id=&#34;21-二分查找&#34;&gt;2.1 二分查找&lt;/h3&gt;
&lt;p&gt;见&lt;a href=&#34;https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/&#34;&gt;二分查找&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;22-划分数组&#34;&gt;2.2 划分数组&lt;/h3&gt;
&lt;p&gt;为了解决这个问题，我们需要理解 “中位数的作用是什么”。在统计中，中位数被用来：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果理解了中位数的划分作用，我们就很接近答案了。&lt;/p&gt;
&lt;p&gt;首先，让我们在任一位置i将 A 划分成两个部分：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;left_A					|	right_A
A[0],A[1],...,A[i-1]	|	A[i],A[i+1],...,A[m-1]
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其中A中有m个元素，则我们有m+1中划分的方法（$i=0 \to m$）&lt;/p&gt;
&lt;p&gt;我们知道：
$$
\begin{align}
&amp;amp; len(leftA) = i,len(rightA) = m-i\\&lt;br&gt;
&amp;amp; 注意：当i=0时，leftA为空集，当i=m时，right A为空集。
\end{align}
$$
采用同样的方式，我们在任一位置j将B划分为两个部分：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;left_B					|	right_B
B[0],B[1],...,B[i-1]	|	B[i],B[i+1],...,B[m-1]
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果我们可以确认：&lt;/p&gt;
&lt;p&gt;$$
\begin{align}
&amp;amp; len(leftPart)  = len(rightPart) \\&lt;br&gt;
&amp;amp; \max(leftPart) \leq \min(rightPart)&lt;/p&gt;
&lt;p&gt;\end{align}
$$&lt;/p&gt;
&lt;p&gt;那么，我们已经将 {A,B} 中的所有元素划分为相同长度的两个部分，且其中一部分中的元素总是大于另一部分中的元素。那么：$median=\frac{\max(leftPart)+\min(rightPart)}{2}$&lt;/p&gt;
&lt;p&gt;要保证这两个条件，我们只需要:&lt;/p&gt;
&lt;p&gt;$$
\begin{align}
&amp;amp;1.i+j=m-i+n-j \ (或：m-i+n-j+1) \\&lt;br&gt;
&amp;amp;若n\geq m,只需要使用i=0 \to m,j=\frac{m+n+1}{2}-i \\&lt;br&gt;
&amp;amp;2.B[j-1]\leq A[i]以及A[i-1]\leq B[j]
\end{align}
$$
ps.1 为了简化分析，我们$A[i-1],B[j-1],A[i],B[j]$总是存在，哪怕出现$i=0,i=m,j=0,j=n$这样的临界条件。最后再讨论如何处理这些临界值。
ps.2为什么$n\geq m$?由于$0\leq i \geq m$且$j = \frac {m+n+1}{2} - i$,保证j不是负数。如果$n&amp;lt;m$,那么j可能为负数，导致错误的结果。&lt;/p&gt;
&lt;p&gt;所以，我们需要做的是，
$$
\begin{align}
&amp;amp; 在[0,m]中搜索并找到目标对象i，以使：\\&lt;br&gt;
&amp;amp; B[j-1]\leq A[i]且A[i-1] \leq B[j] ,其中j=\frac{m+n+1}{2}-i
\end{align}
$$
接着，我们可以按照以下步骤来进行二叉树搜索：&lt;/p&gt;
&lt;p&gt;$$
\begin{align}
&amp;amp;1.设i_{min}=0,i_{max}=m,然后开始在[i_{min},i_{max}]中进行搜索\\&lt;br&gt;
&amp;amp;2.令i=\frac{i_{min}+i_{max}}{2},j=\frac{m+n+1}{2} - i \\&lt;br&gt;
&amp;amp;3.现在我们有len(left_part)=len(right_part).而且只会遇到三种情况：\\&lt;br&gt;
&amp;amp; \ \ * B[j-1] \leq A[i]且A[i-1]\leq B[j]: \\&lt;br&gt;
&amp;amp; \ \ 这意味着我们找到了目标对象i，所以可以停止搜索。\\&lt;br&gt;
&amp;amp; \ \ * B[j-1] &amp;gt; A[i] \\&lt;br&gt;
&amp;amp; \ \ 这意味着A[i]太小，我们必须调整i以使B[j-1] \leq A[i] \\&lt;br&gt;
&amp;amp; 我们可以增大i吗？\\&lt;br&gt;
&amp;amp; —是的，因为i增加的时候，j会被减少。\\&lt;br&gt;
&amp;amp; — 则B[j-1]会减小，而A[i]会增大，那么B[j-1] \leq A[i]就可能被满足。\\&lt;br&gt;
&amp;amp; 我们可以减少i吗？\\&lt;br&gt;
&amp;amp; —不能，因为i减少的时候，j会被增大。\\&lt;br&gt;
&amp;amp; — 则B[j-1]会增大，而A[i]会减少，那么B[j-1] \leq A[i]就不会满足。\\&lt;br&gt;
&amp;amp; 所以我们必须增大i。也就是说，必须将搜索范围调整为[i+1,i_{max}]。 因此，设i_{min} = i+1，并转到步骤 2\\&lt;br&gt;
&amp;amp; \ \ * A[i-1] &amp;gt; B[j]:这意味着A[i-1]太大，我们必须减小i以使 A[i-1] \leq B[j]。 也就是说，我们必须将搜索范围调整为[i_{min},i-1]。\\&lt;br&gt;
&amp;amp;因此，设 i_{max}=i-1 ，并转到步骤 2。
\end{align}
$$&lt;/p&gt;
&lt;p&gt;当找到目标对象&lt;code&gt;i&lt;/code&gt;时，中位数为：
$$
\begin{align}
&amp;amp; 当m+n为奇数时，中位数=\max(A[i-1],B[j-1])\ 
&amp;amp; 当m+n为偶数时，中位数=\frac{\max(A[i-1],B[j-1])+\min(A[i],B[j])}{2}
\end{align}
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特殊情况&lt;/strong&gt;：临界值 $i=0,i=m,j=0,j=n$,此时$A[i-1],B[j-1],A[i],B[j]$可能不存在。 其实这种情况比你想象的要容易得多。&lt;/p&gt;
&lt;p&gt;我们需要做的是确保$\max(left_part) \leq \min(right_part)$。 因此，如果&lt;em&gt;i&lt;/em&gt;和&lt;em&gt;j&lt;/em&gt;不是临界值（这意味着 $A[i-1],B[j-1],A[i],B[j]$全部存在）, 那么我们必须同时检查 $A[i-1] \leq B[j]$ 以及 $B[j-1] \leq A[i]$ 是否成立。 但是如果$A[i-1],B[j-1],A[i],B[j]$中部分不存在，那么我们只需要检查这两个条件中的一个（或不需要检查）。 举个例子，如果 $i=0$，那么 $A[i-1]$ 不存在，我们就不需要检查  是否成立。 $A[i-1] \leq B[j]$所以，我们需要做的是：
$$
\begin{align}
&amp;amp; 在 [0,m] 中搜索并找到目标对象i，以使：\&lt;br&gt;
&amp;amp; (j=0 \ or \ i=m \ or \ B[j-1] \leq A[i]) 或是\&lt;br&gt;
&amp;amp; (i=0 \ or \ j=n \ or \ A[i-1] \leq B[j]) 其中j=\frac{m+n+1}{2}-i&lt;/p&gt;
&lt;p&gt;\end{align}
$$&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;注：i是从0开始找的，若找到i=m，就说明i是完美的
同理j也是一个道理
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;$$
\begin{align}
&amp;amp; 1.(j=0 \ or \ i=m \ or \ B[j-1] \leq A[i]) 或是\&lt;br&gt;
&amp;amp; (i=0 \ or \ j=n \ or \ A[i-1] \leq B[j]) 这说明i已经被找到，停止搜索 \&lt;br&gt;
&amp;amp;2.j&amp;gt;0 \ and \ i&amp;lt;m \ and \ B[j-1] &amp;gt; A[i],这说明i小了，需要增大。\&lt;br&gt;
&amp;amp;3.i&amp;gt;0 \ and \ j &amp;lt; n \ and \ A[i-1] &amp;gt;  B[j]),这说明i大了，需要减小。&lt;/p&gt;
&lt;p&gt;\end{align}
$$&lt;/p&gt;
&lt;p&gt;同时$i&amp;lt;m \Rightarrow j&amp;gt;0以及i&amp;gt;0 \Rightarrow j&amp;lt;n$始终成立，是因为：
$$
\begin{align}
&amp;amp; m \leq n, i&amp;lt;m \Rightarrow j=\frac{m+n+1}{2} - i \geq \frac{m+n+1}{2} - m \geq \frac{2m+1}{2} - m \geq 0\&lt;br&gt;
&amp;amp; m \leq n, i&amp;gt;0 \Rightarrow j=\frac{m+n+1}{2} - i &amp;lt; \frac{m+n+1}{2}  \leq \frac{2n+1}{2}  \leq n
\end{align}
$$
所以，在情况 2 和 3 中，我们不需要检查&lt;code&gt;j&amp;gt;0&lt;/code&gt; 或是&lt;code&gt;j&amp;lt;n&lt;/code&gt;  是否成立。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;89
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;findMedianSortedArrays&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 避免j为负，必须保证m&amp;lt;n
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 若m&amp;gt;n,交换两容器的值，以及容器大小
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;temp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;temp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;nums1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;nums2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;temp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tmp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tmp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//区间[0,m]搜寻i
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;iMin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;iMax&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;halfLen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;iMin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;iMax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;//二分法查询
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;iMin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;iMax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;halfLen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

        &lt;span class=&#34;c1&#34;&gt;// i太小
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;iMax&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; 
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;iMin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;iMin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// i is too small
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

        &lt;span class=&#34;c1&#34;&gt;// i太大
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;iMin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; 
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;iMax&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;iMax&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// i is too big
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

        &lt;span class=&#34;c1&#34;&gt;// i合适
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; 
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
            &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxLeft&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//若i为0即，nums1左侧划分的是没有值的，左侧的最大值即为num2[j-1]
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
            &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
                &lt;span class=&#34;n&#34;&gt;maxLeft&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; 
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//同理j=0
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
            &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
                &lt;span class=&#34;n&#34;&gt;maxLeft&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; 
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//否则取num2[j-1]与nums1[i - 1]的大值作为左边的值
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
                &lt;span class=&#34;n&#34;&gt;maxLeft&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//两容器之和为奇数，中位数为maxLeft
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
            &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
                &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxLeft&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; 
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
			
            &lt;span class=&#34;c1&#34;&gt;//两容器之和为偶数，中位数为（maxLeft+minRight）/2
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minRight&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//i=m，即nums1右侧无划分，右侧的小值取nums2[j]
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
            &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
                &lt;span class=&#34;n&#34;&gt;minRight&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; 
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//同理j=n
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
            &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
                &lt;span class=&#34;n&#34;&gt;minRight&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//否则取num2[j]与nums1[i ]的小值作为右边的值
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; 
            &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
                &lt;span class=&#34;n&#34;&gt;minRight&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maxLeft&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minRight&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;2.0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;


&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时间复杂度：$O(\log(\min(m,n)))$。&lt;/p&gt;
&lt;p&gt;首先，查找的区间是[0,m]。而该区间的长度在每次循环之后都会减少为原来的一半。 所以，我们只需要执行 $\log(m)$次循环。由于我们在每次循环中进行常量次数的操作，所以时间复杂度为 $O(\log(m))$。由于$m \leq n$,所以时间复杂度是$O(\log(\min(m,n)))$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空间复杂度:$O(1)$,只需要恒定的内存来存储 9 个局部变量.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>【LeetCode题解】3、无重复字符的最长子串</title>
      <link>https://littlethinking.cn/post/leetcode%E9%A2%98%E8%A7%A3/leetcode%E9%A2%98%E8%A7%A33%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Thu, 30 Dec 2021 12:01:23 +0800</pubDate>
      
      <guid>https://littlethinking.cn/post/leetcode%E9%A2%98%E8%A7%A3/leetcode%E9%A2%98%E8%A7%A33%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</guid>
      
        <description>&lt;h2 id=&#34;1-题目&#34;&gt;1 题目&lt;/h2&gt;
&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你找出其中不含有重复字符的 &lt;strong&gt;最长子串&lt;/strong&gt; 的长度。&lt;/p&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;示例1 给定 &amp;#34;abcabcbb&amp;#34; ，没有重复字符的最长子串是 &amp;#34;abc&amp;#34; ，那么长度就是 3。
示例2 给定 &amp;#34;bbbbb&amp;#34; ，最长的子串就是 &amp;#34;b&amp;#34; ，长度是 1。
示例3 给定 &amp;#34;pwwkew&amp;#34; ，最长子串是 &amp;#34;wke&amp;#34; ，长度是 3。请注意答案必须是一个子串，&amp;#34;pwke&amp;#34; 是子序列 而不是子串。
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;2-解题&#34;&gt;2 解题&lt;/h2&gt;
&lt;h3 id=&#34;21-暴力法&#34;&gt;2.1 暴力法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;逐个检查所有的子字符串，看它是否不含有重复的字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设我们有一个函数 &lt;code&gt;bool allUnique(String substring)&lt;/code&gt; ，如果子字符串中的字符都是唯一的，它会返回true，否则会返回 false。 我们可以遍历给定字符串 &lt;code&gt;s&lt;/code&gt; 的所有可能的子字符串并调用函数 &lt;code&gt;allUnique&lt;/code&gt;。 如果事实证明返回值为true，那么我们将会更新无重复字符子串的最大长度的答案。&lt;/p&gt;
&lt;p&gt;现在让我们填补缺少的部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为了枚举给定字符串的所有子字符串，我们需要枚举它们开始和结束的索引。假设开始和结束的索引分别为 i 和 j。那么我们有 0 ≤i &amp;lt;j≤n （这里的结束索引 j 是按惯例排除的）。因此，使用 i 从 0 到 n−1 以及 j 从 i+1 到 n 这两个嵌套的循环，我们可以枚举出 &lt;code&gt;s&lt;/code&gt; 的所有子字符串。&lt;/li&gt;
&lt;li&gt;要检查一个字符串是否有重复字符，我们可以使用集合。我们遍历字符串中的所有字符，并将它们逐个放入 &lt;code&gt;set&lt;/code&gt; 中。在放置一个字符之前，我们检查该集合是否已经包含它。如果包含，我们会返回 &lt;code&gt;false&lt;/code&gt;。循环结束后，我们返回 &lt;code&gt;true&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;lengthOfLongestSubstring&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//查询s的所有字串，找到不重复的，找出其最大的子串
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;allUnique&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//不重复，就比较子串长度
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;allUnique&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unordered_set&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; 
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//遍历数组的start到end
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;//判断start到end的每一个数组字符是否在容器set中，若在表明该字串是重复的，直接返回false
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;find&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;	
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;insert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;//不在，将该字符加入set中
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//遍历完start到end段，则表明该子串是不重复的
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;注：unordered_set 容器具有几个特性：
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;1.不再以键值对的形式存储数据，而是直接存储数据的值；
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;2.容器内部存储的各个元素的值都互不相等，且不能被修改；
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;3.不会对内部存储的数据进行排序。
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时间复杂度：$O(n^3)$。&lt;/p&gt;
&lt;p&gt;要验证索引范围在$ [i,j)$内的字符是否都是唯一的，我们需要检查该范围中的所有字符。 因此，它将花费$ O(j-i)$的时间。
对于给定的 &lt;code&gt;i&lt;/code&gt;，对于所有$ j \in [i+1,n)$所耗费的时间总和为： $ \sum\limits_{i+1}^{n}O(j-i)$
因此，执行所有步骤耗去的时间总和为：$  O(\sum\limits_{i=0}^{n-1}\sum\limits_{j=i+1}^{n}j-i) =  O(\sum\limits_{i=0}^{n-1}\frac{(1+n-i)(n-i)}{2})=O(n^3)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空间复杂度:$O(\min(m,n))$,我们需要$O(k)$的空间来检查子字符串中是否有重复字符，其中$ k $表示 &lt;code&gt;Set&lt;/code&gt; 的大小。而 Set 的大小取决于字符串 $n$的大小以及字符集/字母$ m $的大小。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-滑动窗口&#34;&gt;2.2 滑动窗口&lt;/h3&gt;
&lt;p&gt;算法暴力法非常简单。但它太慢了。那么我们该如何优化它呢？&lt;/p&gt;
&lt;p&gt;在暴力法中，我们会反复检查一个子字符串是否含有有重复的字符，但这是没有必要的。如果从索引$i$到$ j-1$之间的子字符串$s_{ij}$已经被检查为没有重复字符。我们只需要检查$s[j]$对应的字符是否已经存在于子字符串$s_{ij}$中。&lt;/p&gt;
&lt;p&gt;要检查一个字符是否已经在子字符串中，我们可以检查整个子字符串，这将产生一个复杂度为$O(n^2)$的算法，但我们可以做得更好。&lt;/p&gt;
&lt;p&gt;通过使用 HashSet 作为滑动窗口，我们可以用$O(1)$的时间来完成对字符是否在当前的子字符串中的检查。&lt;/p&gt;
&lt;p&gt;滑动窗口是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即$[i,j)$ （左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将$[i,j)$向右滑动 1 个元素，则它将变为$[i+1,j+1)  $（左闭，右开）。&lt;/p&gt;
&lt;p&gt;回到我们的问题，我们使用 HashSet 将字符存储在当前窗口$[i,j)$（最初 j=ij=i）中。 然后我们向右侧滑动索引$j$，如果它不在 HashSet 中，我们会继续滑动$j$。直到$s[j]$已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引$i$开头。如果我们对所有的$i$这样做，就可以得到答案。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;lengthOfLongestSubstring&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unordered_set&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//滑动窗口[i,j),先固定i，移动j，
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//若s[j]不在set中，将当前的s[j]存入set，j后移动一位，计算此时的窗口大小；
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//若s[j]已经在set中，删掉set中s[i],i向后移动一位。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//窗口遍历完成整个数组，得到最长的子串大小。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;find&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;insert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; 
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;erase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：$O(2n)=O(n)$,在最差的情况下，每个字符被$i$与$j$访问2次。&lt;/li&gt;
&lt;li&gt;空间复杂度:$O(\min(m,n))$,与之前的方法相同。需要$O(k)$的空间，其中$ k $表示 &lt;code&gt;Set&lt;/code&gt; 的大小。而 Set 的大小取决于字符串 $n$的大小以及字符集/字母$ m $的大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;23-优化的滑动窗口&#34;&gt;2.3 优化的滑动窗口&lt;/h3&gt;
&lt;p&gt;上述的方法最多需要执行 2n 个步骤。事实上，它可以被进一步优化为仅需要 n 个步骤。我们可以定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当我们找到重复的字符时，我们可以立即跳过该窗口。&lt;/p&gt;
&lt;p&gt;也就是说，如果$s[j]$在$[i,j)$范围内有与$j&#39;$重复的字符，我们不需要逐渐增加$i$。 我们可以直接跳过$[i,j&#39;]$范围内的所有元素，并将$i$变为$j&#39;+1$ 。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;lengthOfLongestSubstring&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//创建一个key为char，value为int的容器，
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//分别用来存字符与该字符在字符串的（位置+1）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//（注意字符串数组下标与字符串大小的关系j+1-i）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unordered_map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
     &lt;span class=&#34;c1&#34;&gt;//滑动窗口[i,j),先使i=0，移动j，
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//若s[j]不在set中，将当前的s[j]存入set，j后移动一位，计算此时的窗口大小；
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//若s[j]已经在set中，找到该重复窗口的位置，将i移动到此处的下一位，即i=j&amp;#39;+1。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//窗口遍历完成整个数组，得到最长的子串大小。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;find&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;temp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;find&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])).&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;temp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;temp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：$O(n)$,索引$j$会迭代$n$次。&lt;/li&gt;
&lt;li&gt;空间复杂度:$O(\min(m,n))$,与之前的方法相同。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>【LeetCode题解】2、两数相加</title>
      <link>https://littlethinking.cn/post/leetcode%E9%A2%98%E8%A7%A3/leetcode%E9%A2%98%E8%A7%A32%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Wed, 29 Dec 2021 12:01:23 +0800</pubDate>
      
      <guid>https://littlethinking.cn/post/leetcode%E9%A2%98%E8%A7%A3/leetcode%E9%A2%98%E8%A7%A32%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</guid>
      
        <description>&lt;h3 id=&#34;1-题目&#34;&gt;1 题目&lt;/h3&gt;
&lt;p&gt;给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。&lt;/p&gt;
&lt;p&gt;你可以假设除了数字 0 之外，这两个数字都不会以零开头&lt;/p&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;输入：(2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
输出：7 -&amp;gt; 0 -&amp;gt; 8
原因：342 + 465 = 807
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;2-解题&#34;&gt;2 解题&lt;/h3&gt;
&lt;p&gt;使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐位相加的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/LeetCode%E9%A2%98%E8%A7%A3/002.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/%E9%80%90%E4%BD%8D%E7%9B%B8%E5%8A%A0%E7%9A%84%E8%BF%87%E7%A8%8B.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;就像我们在纸上计算两个数字的和那样，首先从最低有效位也就是列表$l1$和 $l2$的表头开始相加。由于每位数字都应当处于$0&amp;hellip;9$的范围内，我们计算两个数字的和时可能会出现 “溢出”。例如，$5+8=13$  。在这种情况下，我们会将当前位的数值设置为$3$，并将进位$carry=1$带入下一次迭代。进位$carry$必定是$0$或$1$，这是因为两个数字相加（考虑到进位）可能出现的最大和为$9+9+1=19$ 。&lt;/p&gt;
&lt;p&gt;基于上述分析，&lt;strong&gt;伪代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将当前节点初始化为返回列表的哑节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将进位$carry$初始化为1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将$p$和$q$分别初始化为列表$l1$和$l2$的头部。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;遍历列表$l1$和$l2$直至到达它们的尾端。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将$x$设为节点$p$的值。如果$p$已经到达$l1$的末尾，则将其值设置为$0$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将$y$设为节点$q$的值。如果$q$已经到达$l2$的末尾，则将其值设置为$0$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设定$sum=x+y+carry$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新进位的值,$carry=sum/10$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建一个数值为 ( $sum \ mod \ 10$  ) 的新节点，并将其设置为当前节点的下一个节点，然后将当前节点前进到下一个节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同时，将$p$和$q$前进到下一个节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查$carry = 1$是否成立，如果成立，则向返回列表追加一个含有数字$1$ 的新节点。返回哑节点的下一个节点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请注意，我们使用哑节点来简化代码。如果没有哑节点，则必须编写额外的条件语句来初始化表头的值。&lt;/p&gt;
&lt;p&gt;同时需要注意的&lt;strong&gt;以下情况&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;测试用例：
l1 = [0, 1]
l2 = [0, 1, 2]

说明：当一个列表比另一个列表长时。
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;测试用例：
l1 = []
l2 = [0, 1]

说明：当一个列表为空时，即出现空列表。
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;测试用例：
l1 = [9, 9]
l2 = [1]

说明：求和运算最后可能出现额外的进位，这一点很容易被遗忘
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;综上，得到的解题代码（cpp）如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;n&#34;&gt;ListNode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;addTwoNumbers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ListNode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ListNode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;ListNode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ListNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;//创建一个哑节点
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//创建两个链表指针用于遍历l1与l2
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;ListNode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; 
    &lt;span class=&#34;n&#34;&gt;ListNode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;q&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//用于遍历结果列表的链表指针
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;ListNode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;curr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;carry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;						&lt;span class=&#34;c1&#34;&gt;//进位先初始化为0
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;		&lt;span class=&#34;c1&#34;&gt;//若一个链表为空的情况
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;q&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;		&lt;span class=&#34;c1&#34;&gt;// 遍历完l1与l2
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;//若其中一个节点遍历完成，将后续在该链表的值都置为0
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;q&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;carry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;carry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
		
        &lt;span class=&#34;c1&#34;&gt;//注意curr是从哑节点开始的，它的下个节点存储的才是结果位数据
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;curr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ListNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//创建数值为（sum%10）的节点存储当前结果位数据
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;//移动链表指针，准备进行下一位的计算
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;curr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;curr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;q&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;q&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//遍历完检查是否还有存在进位，若有，再创建一个为1的新节点追加至后面
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;carry&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;curr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ListNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;carry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时间复杂度：$O(\max(m,n))$。假设 $m$ 和 $n$分别表示$l1$和$l2$的长度，上面的算法最多重复$\max(m,n)$次。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空间复杂度:$O(\max(m,n))$,新列表的长度最多为$\max(m,n)+1$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>【LeetCode题解】1、两数之和</title>
      <link>https://littlethinking.cn/post/leetcode%E9%A2%98%E8%A7%A3/leetcode%E9%A2%98%E8%A7%A31%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Tue, 28 Dec 2021 12:01:23 +0800</pubDate>
      
      <guid>https://littlethinking.cn/post/leetcode%E9%A2%98%E8%A7%A3/leetcode%E9%A2%98%E8%A7%A31%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      
        <description>&lt;h2 id=&#34;1-题目&#34;&gt;1 题目&lt;/h2&gt;
&lt;p&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的两个整数。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-解题&#34;&gt;2 解题&lt;/h2&gt;
&lt;h3 id=&#34;21-暴力法&#34;&gt;2.1 暴力法&lt;/h3&gt;
&lt;p&gt;暴力法很简单，遍历每个元素 $x$ ，并查找是否存在一个值与$target-x$相等的目标元素。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;twoSum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push_back&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push_back&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：$O(n^2)$。对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$O(n)$的时间，故时间复杂度为$O(n^2)$。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空间复杂度:$O(1)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-两遍哈希表&#34;&gt;2.2 两遍哈希表&lt;/h3&gt;
&lt;p&gt;通过以空间换取速度的方式，我们可以将查找时间从$O(n)$降低到 $O(1)$。哈希表正是为此目的而构建的，它支持以&lt;strong&gt;近似&lt;/strong&gt;恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 $O(n)$。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为$O(1)$。&lt;/p&gt;
&lt;p&gt;一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素 $(target-nums[i])$是否存在于表中。注意，该目标元素不能是$num[i]$本身！&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;twoSum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unordered_map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//创建一个表
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
	&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;//将数组的值作为key，值所对应的数组位置作为value
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 	&lt;span class=&#34;c1&#34;&gt;//遍历目标数组
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;//每一个数组值所对应的另一个值complement
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;complement&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;	
        &lt;span class=&#34;c1&#34;&gt;//以find函数在map中是否存在这样一个键值complement
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unordered_map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;iterator&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;it&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;find&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;complement&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;it&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;it&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;second&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//判断是否找到该值
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push_back&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push_back&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;it&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：$O(n)$，我们把包含有 $n$ 个元素的列表遍历两次。由于哈希表将查找时间缩短到 $O(n)$ ，所以时间复杂度为$O(n)$.&lt;/li&gt;
&lt;li&gt;空间复杂度：$O(n)$，所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 $n$ 个元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;23-一遍哈希表&#34;&gt;2.3 一遍哈希表&lt;/h3&gt;
&lt;p&gt;在2.2的基础上，进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;twoSum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unordered_map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//创建一个表
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//遍历目标数组
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;//每一个数组值所对应的另一个值complement
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;complement&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;//判断map中是否存在这样一个键值complement，若不存在将该nums[i]作为key，i作为value，
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;//若存在，表示直接找到了这一对直接返回结果
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;find&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;complement&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; 
		&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push_back&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push_back&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;find&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;complement&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)).&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：$O(n)$，我们把包含有 $n$ 个元素的列表遍历1次。在表中进行的每次查找只花费的时间$O(1)$，所以时间复杂度为$O(n)$.&lt;/li&gt;
&lt;li&gt;空间复杂度：$O(n)$，所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 $n$ 个元素。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>【CAN总线学习笔记】7、位时间实例</title>
      <link>https://littlethinking.cn/post/can%E6%80%BB%E7%BA%BF/can%E6%80%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07%E4%BD%8D%E6%97%B6%E9%97%B4%E5%AE%9E%E4%BE%8B/</link>
      <pubDate>Sun, 26 Dec 2021 12:01:23 +0800</pubDate>
      
      <guid>https://littlethinking.cn/post/can%E6%80%BB%E7%BA%BF/can%E6%80%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07%E4%BD%8D%E6%97%B6%E9%97%B4%E5%AE%9E%E4%BE%8B/</guid>
      
        <description>&lt;p&gt;本部分将根据Infineon的芯片手册对位时间如何计算和如何配置位时间的寄存器进行说明。&lt;/p&gt;
&lt;p&gt;假设我们有一条需求：&lt;strong&gt;设置CAN通讯的波特率为500KBaud。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-计算&#34;&gt;1 计算&lt;/h3&gt;
&lt;p&gt;Infineon芯片手册提供的CAN总线位时间标准格式定义如下图，后面根据该定义进行求解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/7.%E4%BD%8D%E6%97%B6%E9%97%B4%E5%AE%9E%E4%BE%8B/CAN%E6%80%BB%E7%BA%BF%E4%BD%8D%E6%97%B6%E9%97%B4%E6%A0%87%E5%87%86.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;**设：**晶振时钟周期频率为40MHz，转换为时间表示则为T=1/40MHz=25ns&lt;/p&gt;
&lt;p&gt;NBT=16(即一个位有16个tq，time quantum)，&lt;/p&gt;
&lt;p&gt;因为要设置的波特率为500KBaud，换算时间表示则为1/500KBaud =2000ns，即传输一个位的时间要2000ns。那意味着16个tq就等于2000ns，即tq=125ns。&lt;/p&gt;
&lt;p&gt;又因为有：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/7.%E4%BD%8D%E6%97%B6%E9%97%B4%E5%AE%9E%E4%BE%8B/%E4%BD%8D%E6%97%B6%E9%97%B4%E5%AE%9E%E4%BE%8B%E5%85%AC%E5%BC%8F1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;所以：tq/T=125ns/25ns=5，因为BRP只能为整数，这时取DIV8=0, BRP=4。&lt;/p&gt;
&lt;p&gt;我们已经NBT=16，假设我们采样点取在50%处，即有：&lt;/p&gt;
&lt;p&gt;50%=Tseg2/NBT=[(TSEG2+1)tq]/16*tq**=**(TSEG2+1)/16&lt;/p&gt;
&lt;p&gt;即有：TSEG2=7。&lt;/p&gt;
&lt;p&gt;那么Tseg1= NBT-Tseg2-Tsync=7tq，所以TSEG1=6。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/7.%E4%BD%8D%E6%97%B6%E9%97%B4%E5%AE%9E%E4%BE%8B/%E4%BD%8D%E6%97%B6%E9%97%B4%E5%AE%9E%E4%BE%8B%E5%85%AC%E5%BC%8F2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;再根据下式计算SJW, 这里直接假设TSJW=3*tq能保证下式两个不等式成立（不在此处展开Tprope的讨论），那么SJW=2。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/7.%E4%BD%8D%E6%97%B6%E9%97%B4%E5%AE%9E%E4%BE%8B/%E4%BD%8D%E6%97%B6%E9%97%B4%E5%AE%9E%E4%BE%8B%E5%85%AC%E5%BC%8F3.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;综上有：DIV8=0, BRP=4，TSEG1=6，TSEG2=7，SJW=2。&lt;/p&gt;
&lt;h3 id=&#34;2-寄存器配置&#34;&gt;2 寄存器配置&lt;/h3&gt;
&lt;p&gt;根据上节的计算结果进行位时间寄存器的配置，关于该寄存器的内容以及配置信息见下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/7.%E4%BD%8D%E6%97%B6%E9%97%B4%E5%AE%9E%E4%BE%8B/%E4%BD%8D%E6%97%B6%E9%97%B4%E5%AE%9E%E4%BE%8B%E5%AF%84%E5%AD%98%E5%99%A8%E9%85%8D%E7%BD%AE1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/7.%E4%BD%8D%E6%97%B6%E9%97%B4%E5%AE%9E%E4%BE%8B/%E4%BD%8D%E6%97%B6%E9%97%B4%E5%AE%9E%E4%BE%8B%E5%AF%84%E5%AD%98%E5%99%A8%E9%85%8D%E7%BD%AE2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;经过上述配置，我们成功设置了CAN通讯的波特率为500KBaud。&lt;/p&gt;
&lt;h3 id=&#34;3-补充传输延迟时间tpts&#34;&gt;3 补充：传输延迟时间tPTS&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/7.%E4%BD%8D%E6%97%B6%E9%97%B4%E5%AE%9E%E4%BE%8B/%E4%BC%A0%E8%BE%93%E5%BB%B6%E6%97%B6%E6%97%B6%E9%97%B4tPTS.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;CAN报文在CAN总线上的传输时，物理延迟包含两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在CAN-BUS上传输造成的延迟&lt;/li&gt;
&lt;li&gt;在节点上传输造成延迟&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按照CAN通信协议的规定，补偿给传播延迟的时间长度要至少等于实际实际传播延迟时长的2倍，即：tPTS≥2×tdel=2×(tdel+tBus)&lt;/p&gt;
&lt;p&gt;注意：在CAN总线通信系统中是以时间量子Tq来度量时间的，所以如果延迟补偿时间tPTS = 3.1Tq，那么这个时候要取：tPTS = 4Tq。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;can总线的精彩博文链接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;a href=&#34;https://blog.csdn.net/weixin_40528417/category_7489864.html&#34;&gt;CAN总线_小兵大将&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>【CAN总线学习笔记】6、数据传输同步</title>
      <link>https://littlethinking.cn/post/can%E6%80%BB%E7%BA%BF/can%E6%80%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Sat, 25 Dec 2021 12:01:23 +0800</pubDate>
      
      <guid>https://littlethinking.cn/post/can%E6%80%BB%E7%BA%BF/can%E6%80%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%90%8C%E6%AD%A5/</guid>
      
        <description>&lt;h3 id=&#34;1-位速率概念&#34;&gt;1 位速率概念&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;位速率&lt;/strong&gt;（也叫做&lt;strong&gt;比特率&lt;/strong&gt;）表示的是单位时间内，总线上传输的信息量，即每秒能够传输的二进制位的数量，R=1/T ，单位是bit per second。比如比特率为8bit/s，意思为一秒传输了8bit，包含了8个二进制事件的信息量。注意位速率与&lt;strong&gt;波特率&lt;/strong&gt;不是同一概念。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;摘自：https://zhuanlan.zhihu.com/p/103511011 实际传输中，传输速率以&lt;strong&gt;每秒发送的符号（baud）数量&lt;/strong&gt;进行计算，&lt;strong&gt;即波特率。&lt;/strong&gt; 当一个符号只包含两种可能，即一个事件两种可能，那么此时1baud=1bit。此时波特率等于比特率。 一个符号也有可能包含多个可能，例2中，一个符号中包含四个电平，那么接受端的一个事件，有了abcd四种可能，那么1baud=2bit。此时波特率为比特率的两倍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/6.%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%90%8C%E6%AD%A5/%E4%BD%8D%E9%80%9F%E7%8E%87%E6%A6%82%E5%BF%B5.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-位时序&#34;&gt;2 位时序&lt;/h3&gt;
&lt;p&gt;第3篇讲到帧结构，我们知道每一帧数据（即一个完整的数据帧）有很多位组成，当发送方发送一帧数据到总线时，接收方怎么准确接收到这帧数据呢？实际采用逐位逐位地接收数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/6.%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%90%8C%E6%AD%A5/%E4%BD%8D%E6%97%B6%E5%BA%8F.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;具体来说，将一个位分为4段，如上图所示。这些段又由可称为Time Quantum(以下称为Tq)的最小时间单位构成。1位分为4个段，每个段又由若干个Tq构成，这称为位时序。1位由多少个Tq构成，每个段又由多少个Tq构成等，可以任意设定位时序。通过设定位时序，多个单元可同时采样，也可任意设定采样点。各段的作用和Tq数如下表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/6.%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%90%8C%E6%AD%A5/%E4%BD%8D%E6%97%B6%E5%BA%8F2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;所谓采样点是读取总线电平，并将读到的电平作为位值的点，位置在PBS1结束处。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/6.%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%90%8C%E6%AD%A5/%E4%BD%8D%E6%97%B6%E5%BA%8F3.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;CAN协议的通信方法为NRZ方式，各个位的开头或者结尾都没有附加同步信号。发送单元以与&lt;strong&gt;位时序同步的方式开始发送数据&lt;/strong&gt;。另外，&lt;strong&gt;接收单元根据总线上电平的变化进行同步并进行接收工作&lt;/strong&gt;。但是，&lt;strong&gt;发送单元和接收单元存在的时钟频率误差及传输路径上的（电缆/驱动器等）相位延迟会引起同步偏差&lt;/strong&gt;，因此接收单元通过&lt;strong&gt;硬件同步或者再同步的方法调整时序&lt;/strong&gt;进行接收。&lt;/p&gt;
&lt;h3 id=&#34;3-硬同步&#34;&gt;3 硬同步&lt;/h3&gt;
&lt;p&gt;在总线空闲状态，接收节点检测出帧起始（SOF位）时，会调整当前位的同步段，调整宽度不限。如下图假设这时检测的时SOF位.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/6.%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%90%8C%E6%AD%A5/%E7%A1%AC%E5%90%8C%E6%AD%A51.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;那么硬同步简单说就是接收节点直接与发送节点同步(真有硬的味道)，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/6.%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%90%8C%E6%AD%A5/%E7%A1%AC%E5%90%8C%E6%AD%A52.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;具体解释:
1）发送节点Node_A在发送SOF位时，SOF位的下降沿在SS段；
2）这个时候接收节点Node_B发现自己当前位的SS段和发送节点SOF位的SS段不同步。也就是说当Node_A产生SOF位SS段时，Node_B的当前位的SS段已经在5个Tq之前产生了；
3）于是接收节点Node_B强行将自己当前位的SS段拉到与SOF位的SS段同步。
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;4-再同步&#34;&gt;4 再同步&lt;/h3&gt;
&lt;p&gt;接收节点检测出除SOF位以外的其他位时，进行的同步调整。重同步会通过加长PSB1段，或缩短PBS2段来调整同步，以保证采样点的准确。&lt;/p&gt;
&lt;p&gt;对于再同步，需一个概念SJW（同步跳转宽度），是指PSB1和PSB2再同步时允许跳转的最大宽度，其必须满足以下2个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SJW必须小于PBS1和PBS2的最小值；&lt;/li&gt;
&lt;li&gt;SJW最大值不能超过4。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面看一下再同步的两种情况：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况1： PSB1段加长（发的晚，收的早）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/6.%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%90%8C%E6%AD%A5/%E5%86%8D%E5%90%8C%E6%AD%A51.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;具体解释:
1）发送节点Node_A比接收节点Node_B的时间慢了，也就是说Node_A当前位的ss段产生的时候，Node_B当前位的ss段已经在2个Tq之前产生了；
2）所以这个时候接收节点Node_B就将PBS1延长2个Tq的时间；
3）于是这个时候Node_A当前位的采样点就和Node_B的采样点同步了。
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;情况2：PSB2段缩短（发的早，收的晚）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/6.%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%90%8C%E6%AD%A5/%E5%86%8D%E5%90%8C%E6%AD%A52.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;具体解释:
1）发送节点Node_A当前位的SS段诞生2Tq时长之后，接收节点Node_B的当前位才产生SS段；
2）于是，接收节点Node_B当前位的PBS2段缩短；
3）这样就会导致接收节点Node_B的下一位能够提前2个Tq，从而Node_B的下一位采样点和Node_A下一位的采样点能够同步。
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;5-调整同步的规则&#34;&gt;5 调整同步的规则&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;硬件同步和再同步遵从如下规则。
1) 1个位中只进行一次同步调整。
2) 只有当上次采样点的总线值和边沿后的总线值不同时，该边沿才能用于调整同步。
3) 在总线空闲且存在隐性电平到显性电平的边沿时，则一定要进行硬件同步。
4) 在总线非空闲时检测到的隐性电平到显性电平的边沿如果满足条件（1）和（2），将进行再同步。
但还要满足下面条件。
5) 发送单元观测到自身输出的显性电平有延迟时不进行再同步。
6) 发送单元在帧起始到仲裁段有多个单元同时发送的情况下，对延迟边沿不进行再同步。
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>【CAN总线学习笔记】5、报文过滤</title>
      <link>https://littlethinking.cn/post/can%E6%80%BB%E7%BA%BF/can%E6%80%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05%E6%8A%A5%E6%96%87%E8%BF%87%E6%BB%A4/</link>
      <pubDate>Fri, 24 Dec 2021 12:01:23 +0800</pubDate>
      
      <guid>https://littlethinking.cn/post/can%E6%80%BB%E7%BA%BF/can%E6%80%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05%E6%8A%A5%E6%96%87%E8%BF%87%E6%BB%A4/</guid>
      
        <description>&lt;p&gt;在CAN总线中&lt;strong&gt;没有地址&lt;/strong&gt;的概念，CAN总线是通过&lt;strong&gt;报文ID&lt;/strong&gt;来实现收发数据的。CAN节点上都会有一个&lt;strong&gt;验收滤波ID表&lt;/strong&gt;，其位于CAN节点的验收滤波器中，如果总线上的报文的ID号在某个节点的验收滤波ID表中，那么这一帧报文就能通过该节点验收滤波器的验收，该节点就会接收这一帧报文。假设有设置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/5.%E6%8A%A5%E6%96%87%E8%BF%87%E6%BB%A4/%E6%8A%A5%E6%96%87%E8%BF%87%E6%BB%A41.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可看报文过滤过程如下图示意：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/5.%E6%8A%A5%E6%96%87%E8%BF%87%E6%BB%A4/%E6%8A%A5%E6%96%87%E8%BF%87%E6%BB%A42.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;关于报文过滤具体如何实现，后续文章再详细描述。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>【CAN总线学习笔记】4、总线仲裁</title>
      <link>https://littlethinking.cn/post/can%E6%80%BB%E7%BA%BF/can%E6%80%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%E6%80%BB%E7%BA%BF%E4%BB%B2%E8%A3%81/</link>
      <pubDate>Mon, 20 Dec 2021 12:01:23 +0800</pubDate>
      
      <guid>https://littlethinking.cn/post/can%E6%80%BB%E7%BA%BF/can%E6%80%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%E6%80%BB%E7%BA%BF%E4%BB%B2%E8%A3%81/</guid>
      
        <description>&lt;p&gt;在第三篇中将CAN协议帧结构基本介绍完了，下面来分析下具体的总线仲裁。&lt;/p&gt;
&lt;p&gt;基于上节的仲裁段和控制段，这里主要考虑几种情况的仲裁：&lt;/p&gt;
&lt;p&gt;假设一条CAN总线上有两个节点Node_A和Node_B。在总线空闲时，总线上为隐性电平，就在这个时候Node_A 和 Node_B 这两个节点同时向总线上发送数据，如下图，其中，Tx表示发送，Rx表示接收，也就是说每个节点都有发送与接收。&lt;/p&gt;
&lt;p&gt;当作为发送方的节点会去接收自己发送的内容进行检查，即&lt;strong&gt;回读机制&lt;/strong&gt;（节点在向总线上发送报文的过程中，同时也对总线上的二进制位进行“回读”，对比&lt;strong&gt;该节点发出的二进制位&lt;/strong&gt;与&lt;strong&gt;总线上当前的二进制位&lt;/strong&gt;是否一致，就可节点数据是否被正确接收。)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/4.%E6%80%BB%E7%BA%BF%E4%BB%B2%E8%A3%81/%E4%BB%B2%E8%A3%81%E8%BF%87%E7%A8%8B.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;**情况1：**仲裁在前11位ID就结束 ，如上图。&lt;/p&gt;
&lt;p&gt;从D28-D18，采用线与机制，逐位进行比较，一旦某位出现不同，上图的ID25，则显性位覆盖隐性位，仲裁结束，显性位的对应节点胜出，上图的Node_A。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/4.%E6%80%BB%E7%BA%BF%E4%BB%B2%E8%A3%81/%E6%83%85%E5%86%B51.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;**情况2：**仲裁在前11位ID未结束，即说明前11位ID相同&lt;/p&gt;
&lt;p&gt;在这种情况下，我们就需要回顾一下前面的一个表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/4.%E6%80%BB%E7%BA%BF%E4%BB%B2%E8%A3%81/%E6%83%85%E5%86%B52.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;根据这个表，我们可以进一步分为4种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;标准格式的数据帧与遥控帧&lt;/strong&gt;，看RTR位，数据帧的RTR位恒为显性，遥控帧的RTR位恒为隐性。故前11位ID号相同时，&lt;strong&gt;标准数据帧优先级高于标准遥控帧&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展格式的数据帧与遥控帧&lt;/strong&gt;，在前11位ID和后18位ID全相同的情况，与上条一致。&lt;/li&gt;
&lt;li&gt;**数据帧的标准格式与扩展格式，**比较标准格式的RTR位与扩展格式的SRR位，标准格式的RTR位恒为显性，扩展格式的SRR位恒为隐性。故前11位ID号相同时，&lt;strong&gt;标准数据帧优先级高于扩展数据帧&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;遥控帧的标准格式与扩展格式&lt;/strong&gt;，看IDE位，扩展格式的IDE位恒为隐性，标准格式的IDE位在控制段，恒为显性。故&lt;strong&gt;前11位ID号相同时，标准遥控帧优先级高于扩展遥控帧&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过上述分析，我们可以知道在前11位ID号相同时，根据协议设定的RTR, SRR, IDE，就可以保证如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RTR：保证数据帧优先级高于遥控帧；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SRR ：保证标准数据帧的优先级高于扩展数据帧；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IDE ：保证标准遥控帧的优先级高于扩展遥控帧。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>【CAN总线学习笔记】3、CAN协议帧结构</title>
      <link>https://littlethinking.cn/post/can%E6%80%BB%E7%BA%BF/can%E6%80%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03can%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 19 Dec 2021 12:01:23 +0800</pubDate>
      
      <guid>https://littlethinking.cn/post/can%E6%80%BB%E7%BA%BF/can%E6%80%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03can%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/</guid>
      
        <description>&lt;p&gt;在第二篇中仲裁机制部分我们提到CAN协议帧，总的来说CAN协议帧有5种类型，下面逐个展开。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E5%B8%A7%E7%A7%8D%E7%B1%BB%E5%8F%8A%E7%94%A8%E9%80%94.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于数据帧与遥控帧的最大差别在于遥控帧没有数据段，所以将两者放在一起讲述：&lt;/p&gt;
&lt;h3 id=&#34;1-数据帧和遥控帧&#34;&gt;1 数据帧和遥控帧&lt;/h3&gt;
&lt;p&gt;数据帧和遥控帧都有&lt;strong&gt;标准格式&lt;/strong&gt;和&lt;strong&gt;扩展格式，&lt;strong&gt;这2种格式都具有&lt;/strong&gt;相同的帧结构&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;数据帧由7个段构成，遥控帧由6个段构成。先看&lt;strong&gt;数据帧&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%B8%A7%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E4%B8%A4%E7%A7%8D%E6%A0%BC%E5%BC%8F.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%B8%A7%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E4%B8%A4%E7%A7%8D%E6%A0%BC%E5%BC%8F-02.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里结合实际采集的CAN总线电压信号来看下标准格式的数据帧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E6%A0%87%E5%87%86%EF%BC%88%E6%A0%BC%E5%BC%8F%EF%BC%89%E6%95%B0%E6%8D%AE%E5%B8%A7%E7%9A%84CAN%E6%80%BB%E7%BA%BF%E7%94%B5%E5%8E%8B.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;再看&lt;strong&gt;遥控帧&lt;/strong&gt;（也叫远程帧）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E9%81%A5%E6%8E%A7%E5%B8%A7%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E4%B8%A4%E7%A7%8D%E6%A0%BC%E5%BC%8F.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过对比&lt;strong&gt;数据帧和遥控帧&lt;/strong&gt;有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据帧与遥控帧的不同&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遥控帧的RTR位为隐性位，没有数据段。&lt;/li&gt;
&lt;li&gt;没有数据段的数据帧与遥控帧可通过RTR位区分。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;遥控帧没有数据段，数据长度码如何表示？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遥控帧的数据长度以所请求数据帧的数据长度码表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有数据段的数据帧有何用途？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，可以用于各单元的定期连接确认/应答、或仲裁段本身带有实质性信息的情况下。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过对数据帧和遥控帧有了基本认识，下面我们再具体了解下每个段。&lt;/p&gt;
&lt;h4 id=&#34;11-帧起始sof-start-of-frame&#34;&gt;1.1 帧起始(SOF, Start of Frame)&lt;/h4&gt;
&lt;p&gt;表示&lt;strong&gt;帧开始的段&lt;/strong&gt;，&lt;strong&gt;1个位的显性位&lt;/strong&gt;。（总线空闲时为隐性位，故帧起始以显性位非常好识别），对于数据帧和遥控帧的标准/扩展格式均如此。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E5%B8%A7%E8%B5%B7%E5%A7%8B.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;12-仲裁段arbitration-field&#34;&gt;1.2 仲裁段（Arbitration field）&lt;/h4&gt;
&lt;p&gt;表示&lt;strong&gt;数据的优先级的段&lt;/strong&gt;，其作用就是根据报文ID来确定其发送优先级。标准格式和扩展格式在此的构成有所不同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E4%BB%B2%E8%A3%81%E6%AE%B5.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里对比数据帧与遥控帧各自的两个格式，其不同为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%B8%A7%E4%B8%8E%E9%81%A5%E6%8E%A7%E5%B8%A7%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A0%BC%E5%BC%8F.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;针对上表的这种设计，后面会具体分析其在仲裁过程的作用。&lt;/p&gt;
&lt;h4 id=&#34;13-控制段control-field&#34;&gt;1.3 控制段（Control field）&lt;/h4&gt;
&lt;p&gt;表述&lt;strong&gt;数据段的字节数&lt;/strong&gt;，由6个位构成，标准格式和扩展格式的构成有所不同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E6%8E%A7%E5%88%B6%E6%AE%B5-1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E6%8E%A7%E5%88%B6%E6%AE%B5-2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E6%8E%A7%E5%88%B6%E6%AE%B5-3.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;14-数据段data-field&#34;&gt;1.4 数据段(Data Field)&lt;/h4&gt;
&lt;p&gt;数据段可包含0-8个字节的数据，从MSB（最高位）开始输出。遥控帧没有此段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E6%AE%B5.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;15-crc段cyclic-redundancy-check-field&#34;&gt;1.5 CRC段（Cyclic Redundancy Check Field）&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;检查帧传输错误的帧&lt;/strong&gt;，由15个位的CRC顺序和1个位的CRC界定符（用于分隔位）构成。CRC界定符恒为隐性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/CRC%E6%AE%B5.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里CRC顺序是根据多项式生成的CRC值，CRC的计算范围包括帧起始，仲裁段，控制段和数据段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/CRC%E5%BA%8F%E5%88%97%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;附2：&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Cyclic_redundancy_check&#34;&gt;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&lt;/a&gt; , 如何通俗的理解CRC校验并用C语言实现， &lt;a href=&#34;https://zhuanlan.zhihu.com/p/77408094&#34;&gt;https://zhuanlan.zhihu.com/p/77&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;16-ack段acknowledge-field&#34;&gt;1.6 ACK段（Acknowledge Field）&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;用来确认是否正常接收&lt;/strong&gt;。由ACK槽（ACK Slot）和ACK界定符2个位构成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/ACK%E6%AE%B5.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/ACK%E6%AE%B5-1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/ACK%E6%AE%B5-2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;17-帧结束end-of-frame&#34;&gt;1.7 帧结束(End of Frame)&lt;/h4&gt;
&lt;p&gt;表示&lt;strong&gt;该帧的结束的段&lt;/strong&gt;。由7个位的隐性位构成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E5%B8%A7%E7%BB%93%E6%9D%9F.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-错误帧&#34;&gt;2 错误帧&lt;/h3&gt;
&lt;p&gt;用于在接收和发送消息时&lt;strong&gt;检测出错误通知错误的帧&lt;/strong&gt;，错误帧由&lt;strong&gt;错误标志&lt;/strong&gt;和&lt;strong&gt;错误界定符&lt;/strong&gt;构成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E9%94%99%E8%AF%AF%E5%B8%A7.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图的错误标志包括&lt;strong&gt;主动错误标志&lt;/strong&gt;（6个位的显性位）和&lt;strong&gt;被动错误标志&lt;/strong&gt;（6个位的隐性位）两种。主动错误标志处于主动错误状态下的单元检测出错误时输出的错误标志。被动错误标志处于被动错误状态的单元检测出错误时输出的错误标志。错误界定符由8个位的隐性位构成。&lt;/p&gt;
&lt;p&gt;注意上图0~6位的&lt;strong&gt;错误标志重叠&lt;/strong&gt;，这段怎么确定呢？需先介绍2个概念：&lt;strong&gt;位填充&lt;/strong&gt;和&lt;strong&gt;错误类型&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;21-位填充bit-stuffing&#34;&gt;2.1 位填充(Bit Stuffing)&lt;/h4&gt;
&lt;p&gt;位填充是为防止突发错误而设定的功能。当同样的电平持续5位则添加一个位的反型数据位：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E4%BD%8D%E5%A1%AB%E5%85%85.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E4%BD%8D%E5%A1%AB%E5%85%85-1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;22-错误类型&#34;&gt;2.2 错误类型&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/CRC%E5%8C%B9%E9%85%8D%E7%A4%BA%E6%84%8F.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/CRC%E9%94%99%E8%AF%AF.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;针对上述&lt;strong&gt;位错误&lt;/strong&gt;再做说明：
所谓“发出的电平与从总线上回读的电平不一致”，指的就是&lt;strong&gt;节点向总线发出隐性位，却从总线上回读到显性位&lt;/strong&gt;或者&lt;strong&gt;节点向总线发出显性位，却从总线上回读到隐性位&lt;/strong&gt;这两种情况。有三种例外情况不属于位错误：
在仲裁区，节点向总线发送隐性位却回读到显性位，不认为是位错误，这种情况表示该节点仲裁失败；
在ACK槽，节点向总线发送隐性位却回读到显性位，不认为是位错误，这种情况表示，该节点当前发送的这一帧报文至少被一个其它节点正确接收；
一个节点发送被动错误标志，该节点向总线发送连续六个隐性位（被动错误标志）却回读到显性位，不认为是位错误。因为被动错误标志是六个连续的隐性位，所以在总线上按照线与机制，有可能这六个连续隐性位被其它节点发送的显性电平覆盖。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;23-错误处理&#34;&gt;2.3 错误处理&lt;/h4&gt;
&lt;p&gt;错误状态的种类有：&lt;strong&gt;主动错误状态&lt;/strong&gt;，&lt;strong&gt;被动错误状态&lt;/strong&gt;和&lt;strong&gt;总线关闭态&lt;/strong&gt;3种状态。单元始终处于3种状态之一。&lt;/p&gt;
&lt;p&gt;（1）主动错误状态：可以正常参加总线通信的状态，处于主动错误状态的单元检测出错误时，输出主动错误标志。&lt;/p&gt;
&lt;p&gt;（2）被动错误状态：是易引起错误的状态。处于被动错误状态的单元虽能参加总线通信，但为不妨碍其他单元通信，接收时不能积极地发送错误通知；处于被动错误状态的单元即使检测出错误，而其它处于主动错误状态的单元如果没发现错误，整个总线也被认为是没有错误的。处于被动错误状态的单元检测出错误时，输出被动错误标志。另外，处于被动错误状态的单元在不能马上再次开始发送。在开始下次发送前，在间隔帧期间内必须插入“延迟传送”（8个位的隐性位）。&lt;/p&gt;
&lt;p&gt;（3）总线关闭态是不能参加总线上通信的状态。信息的接收和发送均被禁止。&lt;/p&gt;
&lt;p&gt;以上这些状态依靠发送错误计算和接收错误计数来管理，根据计数值决定进入何种状态。错误状态和计数值的关系如下表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%811.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E5%8D%95%E5%85%83%E7%9A%84%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;发送错误计数值和接收错误计数值根据一定的条件发送变化。错误计数值的变动条件如下表，一次数据的接收和发送可能同时满足多个条件。错误计数器在错误标志的第一个位出现的时间点上开始计数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%812.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;24-错误帧发送&#34;&gt;2.4 错误帧发送&lt;/h4&gt;
&lt;p&gt;检查到错误后，什么时候发送错误帧呢？按照CAN协议的规定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位错误、填充错误、格式错误、ACK错误。&lt;strong&gt;在错误产生的那一位的下一位开始发送错误帧&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;CRC错误。&lt;strong&gt;紧随ACK界定符后的位发送错误帧&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体来看一个例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E9%94%99%E8%AF%AF%E5%B8%A7%E4%BE%8B%E5%AD%901.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1）发送节点Node_A发送一个显性位，但是却从总线上听到一个隐形位，于是Node_A节点就会检测到一个位错误；&lt;/li&gt;
&lt;li&gt;2）Node_A检测到位错误之后，立即在下一位开始发送主动错误帧：6个连续显性位的主动错误标志+8个连续隐性位的错误界定符；&lt;/li&gt;
&lt;li&gt;3）对应Node_A发出的主动错误标志，总线上电平为6个连续显性位；&lt;/li&gt;
&lt;li&gt;4）接收节点Node_B和Node_C从总线上听到连续6个显性位，那么就会检测到一个填充错误，于是这两个节点都会发送主动错误帧；&lt;/li&gt;
&lt;li&gt;5）对应Node_B和Node_C发出的主动错误标志，总线电平又有6个连续显性电平，对应Node_B和Node_C发出的错误界定符，总线电平有8个连续的隐性电平。&lt;/li&gt;
&lt;li&gt;6）在间歇场之后，Node_A节点重新发送刚刚出错的报文。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在了解了错误帧的发送后，回到之前提到**错误标志重叠部分是怎样形成的，**再看一个例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E9%94%99%E8%AF%AF%E5%B8%A7%E4%BE%8B%E5%AD%902.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在这个例子，我们知道位错误的错误标志与填充错误的错误标志重叠2位，剩下部分还有4位&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E9%94%99%E8%AF%AF%E6%A0%87%E5%BF%97.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-过载帧&#34;&gt;3 过载帧&lt;/h3&gt;
&lt;p&gt;过载帧是用于接收单元通知其尚未完成接收准备的帧。过载帧由过载标志（6个位的显性位）和过载界定符(8个位的隐性位)构成。过载界定符的构成与错误界定符的构成相同。过载帧的构成如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E8%BF%87%E8%BD%BD%E5%B8%A7.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于过载帧的帧结构我们可以这样理解：接收节点达到接收极限时，就会发出过载帧到总线上，显然，过载标志的6个连续显性位会屏蔽掉总线上其它节点的发送，也就是说这个时候的接收节点通过发送过载帧的方式来破坏其它节点的发送，这样在接收节点发送过载帧期间，其它节点就不能成功发送报文，于是就相当于把其它节点的发送推迟了，也就是说接收节点在其发送过载帧的这段时间得以“休息”。&lt;/p&gt;
&lt;p&gt;有3种情况会引起过载帧：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接收节点自身原因。接收节点由于某种原因需要延迟接收下一个数据帧或者遥控帧。&lt;/li&gt;
&lt;li&gt;在帧间隔的间歇段的第一位和第二位检测到一个显性位（正常的间歇段都是隐性位）。帧间隔的间隔段本应是三个连续的隐性位，如果接收节点在间隔段检测到显性位，那么就意味着此时有报文发向接收节点，但这个时候是不应该有报文发来的，于是接收节点发送过载帧。&lt;/li&gt;
&lt;li&gt;CAN节点在错误界定符或过载界定符的第八位(最后一位)听到一个显性位0，节点会发送一个过载帧，且错误计数器不会增加。接收节点在错误界定符和过载界定符的最后一位听到显性位，也意味着有报文发向接收节点，但这个时候是不应该有报文发来的，于是接收节点发送过载帧。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-帧间隔&#34;&gt;4 帧间隔&lt;/h3&gt;
&lt;p&gt;帧间隔是用于分隔数据帧和遥控帧的帧。数据帧和遥控帧可通过插入帧间隔将本帧与前面的任何帧（数据帧、遥控帧、错误帧、过载帧）分开。过载帧和错误帧前不能插入帧间隔。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/image/CAN%E6%80%BB%E7%BA%BF/3.CAN%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%BB%93%E6%9E%84/%E5%B8%A7%E9%97%B4%E9%9A%94.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;针对上图，间隔为3个位的隐性位；总线空闲为隐性电平，无长度限制（0亦可）；延迟传送为8个位的隐性位，只在处于被动错误状态的单元刚发送一个消息后的帧间隔中包含的段。这里为什么需要延迟传送段呢？&lt;/p&gt;
&lt;p&gt;首先，考虑主动错误状态的节点A，发送主动错误标志之后，随之就要重新发送刚刚发送失败的报文，但是为了间隔开与前面刚刚发送的错误帧，总线在错误帧之后就会插入３个隐形位的帧间隔，在这３个隐形位期间，其它的节点不足以判定总线空闲（需要连续11个隐性位才能判定），所以节点A仍然占据着总线的控制权，于是在帧间隔之后，节点A能够接着发送报文。现在节点A转入到被动错误状态了，说明它已经不是很可靠了，这个时候如果没有延迟传送段，在节点A发出被动错误标志之后，它仍然能够在3位的帧间隔之后立即重新发送报文，这是不符合我们对被动错误状态的处理要求的当然也是不符合CAN协议的，于是乎对于发送出被动错误标志的节点，总线在帧间隔中加入了８个连续隐性位的延迟传送段，这样的3+8=11个连续隐性位。就能让节点A在这个帧间隔期间失去对总线的控制权，从而优先保证其它正常(处于主动错误状态)节点能够使用总线，而不必等着一个已经不可靠的节点A占据总线。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>【CAN总线学习笔记】2、CAN总线特性</title>
      <link>https://littlethinking.cn/post/can%E6%80%BB%E7%BA%BF/can%E6%80%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02can%E6%80%BB%E7%BA%BF%E7%89%B9%E6%80%A7/</link>
      <pubDate>Sat, 18 Dec 2021 12:01:23 +0800</pubDate>
      
      <guid>https://littlethinking.cn/post/can%E6%80%BB%E7%BA%BF/can%E6%80%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02can%E6%80%BB%E7%BA%BF%E7%89%B9%E6%80%A7/</guid>
      
        <description>&lt;h3 id=&#34;1-多主工作方式&#34;&gt;1 多主工作方式&lt;/h3&gt;
&lt;p&gt;CAN总线上的所有节点没有主从之分，反应在数据传输上是：&lt;strong&gt;在总线空闲状态下，任意节点都可以向总线上发送信息&lt;/strong&gt;。另外：最先向总线发送信息的节点获得总线的发送权；当多个节点同时向总线发送消息时，所发送消息的优先权高的那个节点获得总线的发送权。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/2.%E6%80%BB%E7%BA%BF%E7%89%B9%E6%80%A7/%E5%A4%9A%E4%B8%BB%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图说明：0x12优先级高于0x67，所以0x12先于0x67发送；紧接着0x52也要求发送，同样其优先级也高于0x67，所以0x52先于0x67发送，依次类推。这里0x12优先级高于0x67是怎么判断的呢？这就下个特点相关。&lt;/p&gt;
&lt;h3 id=&#34;2-非破坏性仲裁机制&#34;&gt;2 非破坏性仲裁机制&lt;/h3&gt;
&lt;p&gt;非破坏性仲裁机制是一种既不会造成已发送数据的延迟，也不会破坏已经发送的数据的仲裁机制，其具体实施需要了解&lt;strong&gt;CAN协议帧结构，线与机制&lt;/strong&gt;等。其中，线与机制简单说就是位与计算，显性电平会覆盖隐性电平（换种方式理解：电路通路情况下，有一个端点接地（GND），那么整个电路电压就接地了）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/2.%E6%80%BB%E7%BA%BF%E7%89%B9%E6%80%A7/%E7%BA%BF%E4%B8%8E%E6%9C%BA%E5%88%B6%E5%9B%BE%E8%A7%A3.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/2.%E6%80%BB%E7%BA%BF%E7%89%B9%E6%80%A7/%E6%98%BE%E6%80%A7%E4%B8%8E%E9%9A%90%E6%80%A7%E7%94%B5%E5%B9%B3.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;再了解线与机制后，看一个简单的仲裁例子，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/2.%E6%80%BB%E7%BA%BF%E7%89%B9%E6%80%A7/%E4%BB%B2%E8%A3%81%E6%9C%BA%E5%88%B6.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图：假设CAN总线上只有两个节点 A和B，它俩的ID用逻辑电平表示，我们规定：从SOF位开始，从左往右逐位比较，只要出现位不一样，比较就结束，显性电平者胜出，有权发送。&lt;/p&gt;
&lt;p&gt;当节点A，B都发送请求时，开始逐位比较，直到它俩的ID7位，节点A为显性电平，节点B为隐性电平。根据线与机制，节点A胜出，优先发送。这就是一个大致的非破坏性仲裁过程。为了精准地实施仲裁过程，对CAN协议帧结构有严谨的设计，后续将会详细分析。&lt;/p&gt;
&lt;h3 id=&#34;3-系统的柔软性&#34;&gt;3 系统的柔软性&lt;/h3&gt;
&lt;p&gt;与总线相连的节点没有类似于“地址”的信息。因此在总线上增加节点时，连接在总线上的其它节点的软硬件及应用层都不需要改变。&lt;/p&gt;
&lt;h3 id=&#34;4-通信速度&#34;&gt;4 通信速度&lt;/h3&gt;
&lt;p&gt;根据整个网络的规模，可设定适合的通信速度。在同一网络中，所有单元必须设定成统一的通信速度。即使有一个单元的通信速度与其它的不一样，此单元也会输出错误信号，妨碍整个网络的通信。不同网络间则可以有不同的通信速度。（简单一句话理解：&lt;strong&gt;双方必须需要在同一频道交流，不然沟通就有障碍&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/2.%E6%80%BB%E7%BA%BF%E7%89%B9%E6%80%A7/%E9%80%9A%E4%BF%A1%E9%80%9F%E5%BA%A6.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;5-远程数据请求&#34;&gt;5 远程数据请求&lt;/h3&gt;
&lt;p&gt;可通过发送“遥控帧” 请求其他单元发送数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/2.%E6%80%BB%E7%BA%BF%E7%89%B9%E6%80%A7/%E8%BF%9C%E7%A8%8B%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;6-信息广播&#34;&gt;6 信息广播&lt;/h3&gt;
&lt;p&gt;信息广播就如：节点A发送一条ID 0x12的信息，然后节点B,C,D都能收到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/2.%E6%80%BB%E7%BA%BF%E7%89%B9%E6%80%A7/%E4%BF%A1%E6%81%AF%E5%B9%BF%E6%92%AD.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图节点B,C,D最终是否会接收这个0x12发送信息，与他们设置相关，如下图只有节点B设置接收，C，D将会丢弃该条信息，这个过程与报文过滤相关。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>【CAN总线学习笔记】1、CAN概述</title>
      <link>https://littlethinking.cn/post/can%E6%80%BB%E7%BA%BF/can%E6%80%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01can%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Wed, 17 Nov 2021 12:01:23 +0800</pubDate>
      
      <guid>https://littlethinking.cn/post/can%E6%80%BB%E7%BA%BF/can%E6%80%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01can%E6%A6%82%E8%BF%B0/</guid>
      
        <description>&lt;p&gt;控制器局域网CAN( Controller Area Network)属于&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E7%8E%B0%E5%9C%BA%E6%80%BB%E7%BA%BF&#34;&gt;现场总线&lt;/a&gt;的范畴，是一种有效支持&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F&#34;&gt;分布式控制系统&lt;/a&gt;的&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1&#34;&gt;串行通信&lt;/a&gt;网络。是由&lt;strong&gt;德国博世公司在20世纪80年代专门为汽车行业开发的一种&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1&#34;&gt;串行通信&lt;/a&gt;总线。&lt;strong&gt;由于其高性能、高可靠性以及独特的设计而越来越受到人们的重视，被广泛应用于&lt;/strong&gt;汽车业、航空业、工业控制、安全防护&lt;/strong&gt;等领域。
随着&lt;a href=&#34;https://baike.baidu.com/item/CAN%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE&#34;&gt;CAN总线协议&lt;/a&gt;在各个行业和领域的广泛应用，对其的通信格式标准化也提出了更严格的要求。&lt;strong&gt;1991年CAN总线技术规范（Version2.0）&lt;strong&gt;制定并发布。该技术规范共包括A和B两个部分。其中&lt;/strong&gt;2.0A给出了CAN报文标准格式，而2.0B给出了标准的和扩展的两种格式&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;1-can总线架构简介&#34;&gt;1 CAN总线架构简介&lt;/h3&gt;
&lt;p&gt;CAN总线是一种用于在不同的ECU（电子控制单元）之间传输数据的线，CAN总线协议是一种ISO 国际标准化的串行通信协议，有 ISO-11898 和 ISO-11519两个系列。其定义有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ISO-11898 定义了通信速率为 125 kbps ~1Mbps 的&lt;strong&gt;高速 CAN 通信标准&lt;/strong&gt;，属于&lt;strong&gt;闭环总线&lt;/strong&gt;，传输速率可达1Mbps，总线长度 ≤ 40米，如图。&lt;/li&gt;
&lt;li&gt;ISO11519 定义了通信速率为 10～125 kbps 的&lt;strong&gt;低速 CAN 通信标准&lt;/strong&gt;，属于&lt;strong&gt;开环总线&lt;/strong&gt;，传输速率为40kbps时，总线长度可达1000米，如图。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/1.%E6%A6%82%E8%BF%B0/%E4%B8%A4%E7%B1%BBCAN%E6%80%BB%E7%BA%BF.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;高速CAN和低速CAN广泛应用于汽车总线，如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/1.%E6%A6%82%E8%BF%B0/%E4%B8%A4%E7%B1%BBCAN%E6%80%BB%E7%BA%BF%E5%BA%94%E7%94%A8%E5%9C%A8%E6%B1%BD%E8%BD%A6.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//blog.csdn.net/toywang123/article/details/108872993&#34;&gt;CAN总线终端电阻的作用？为什么是120Ω？为什么是0.25W？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CAN通讯速率(&lt;strong&gt;位速率&lt;/strong&gt;)与CAN总线长度的关系大致如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/1.%E6%A6%82%E8%BF%B0/%E4%BD%8D%E9%80%9F%E7%8E%87%E4%B8%8E%E6%80%BB%E7%BA%BF%E9%95%BF%E5%BA%A6%E5%85%B3%E7%B3%BB.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;以上介绍了高低速CAN两种总线架构的基本概念，接下来具体看看这两种CAN总线。&lt;/p&gt;
&lt;h3 id=&#34;2-can总线结构信息&#34;&gt;2 CAN总线结构信息&lt;/h3&gt;
&lt;p&gt;将上图2细化，我们可以看到两种CAN总线结构都有CAN_H，CAN_L两根线和多个节点。其中CAN_H和CAN_L线是以双绞形式缠绕，每个节点都有CAN收发器（transceiver）和CAN控制器（controller），CAN收发器和CAN控制器可能集成在芯片（on-chip），也可能是独立于芯片(off-chip)。（图3列举了两种CAN收发器&amp;ndash;TJA1054和82C250）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/1.%E6%A6%82%E8%BF%B0/%E4%B8%A4%E7%B1%BBCAN%E6%80%BB%E7%BA%BF_2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/1.%E6%A6%82%E8%BF%B0/%E5%8F%8C%E7%BB%9E%E7%BA%BF%E5%BD%A2%E5%BC%8F%EF%BC%88%E6%8F%90%E9%AB%98%E6%8A%97%E5%B9%B2%E6%89%B0%E8%83%BD%E5%8A%9B%EF%BC%89.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;附1: &lt;a href=&#34;https://zhuanlan.zhihu.com/p/26544567&#34;&gt;CAN总线抗干扰的6条“军规”&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-can总线信号&#34;&gt;3 CAN总线信号&lt;/h3&gt;
&lt;p&gt;CAN总线上，信号表现为电压形式，通过CAN_H和CAN_L线上的&lt;strong&gt;电位差来表示CAN信号&lt;/strong&gt;，分为**显性电平(dominant)和隐性电平(recessive)**两种类型。其中显性电平规定为逻辑0，隐性电平则为逻辑1。其具体定义可通过下图来理解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/1.%E6%A6%82%E8%BF%B0/CAN%E4%BF%A1%E5%8F%B7%E5%AE%9A%E4%B9%89.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;具体说，如上图第1幅图：当CAN_H和CAN_L的电压均为2.5v，两者电压差为0，就规定CAN信号为隐性电平；当CAN_H的电压为3.5v，CAN_L的电压为1.5v，两者电压差为2V，就规定CAN信号为显性电平。这里实际的规定是：电压差满足定义的一定范围，就可以认为是显性电平或者隐性电平，比如电压差在1.5-2.5v范围，都认为是显性电平。&lt;/p&gt;
&lt;p&gt;为了加深理解，看了一段实际采集的电压形式的CAN信号：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/1.%E6%A6%82%E8%BF%B0/%E9%AB%98%E9%80%9FCAN%E6%80%BB%E7%BA%BF%E5%AE%9E%E9%99%85%E7%94%B5%E5%8E%8B%E7%8A%B6%E6%80%81.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-can信号传输&#34;&gt;4 CAN信号传输&lt;/h3&gt;
&lt;p&gt;上述的电位差（差分电平）与逻辑电平由CAN收发器实现。在发送过程，CAN控制器将CPU传来的信号转换为逻辑电平。CAN收发器接收逻辑电平之后，再将其转换为差分电平输出到CAN总线上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/1.%E6%A6%82%E8%BF%B0/CAN%E4%BF%A1%E5%8F%B7%E5%8F%91%E9%80%81.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在接收过程，CAN收发器将CAN_H 和 CAN_L 线上传来的差分电平转换为逻辑电平输出到CAN控制器，CAN控制器再把该逻辑电平转化为相应的信号发送到CPU上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/CAN%E6%80%BB%E7%BA%BF/1.%E6%A6%82%E8%BF%B0/CAN%E4%BF%A1%E5%8F%B7%E6%8E%A5%E6%94%B6.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;通俗地讲，就是发送方通过CAN收发器使总线电平发生变化，将其信息传递到CAN总线上。接收方通过监听总线电平，将总线上的消息读入自己的CAN收发器。&lt;/p&gt;
&lt;h3 id=&#34;5-小结&#34;&gt;5 小结&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;CAN总线有2种架构，CAN信号有2种形式，CAN信号发送和接收2个过程。&lt;/strong&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>【C&#43;&#43;】UML类图</title>
      <link>https://littlethinking.cn/post/cpp/uml%E7%B1%BB%E5%9B%BE/</link>
      <pubDate>Mon, 15 Nov 2021 12:01:23 +0800</pubDate>
      
      <guid>https://littlethinking.cn/post/cpp/uml%E7%B1%BB%E5%9B%BE/</guid>
      
        <description>&lt;h2 id=&#34;1-什么是uml类图&#34;&gt;1 什么是UML类图&lt;/h2&gt;
&lt;p&gt;在UML 2.*的13种图形中，类图是使用频率最高的UML图之一。类图是面向对象系统建模中最常用和最重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。&lt;/p&gt;
&lt;h2 id=&#34;2-怎么画uml类图&#34;&gt;2 怎么画UML类图&lt;/h2&gt;
&lt;h3 id=&#34;21-类的表示&#34;&gt;2.1 类的表示&lt;/h3&gt;
&lt;p&gt;在 UML 类图中，一个矩形代表一个类，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/cpp/UML%E7%B1%BB%E5%9B%BE/%E7%B1%BB%E5%9B%BE-01.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;矩形分为三部分：&lt;/p&gt;
&lt;p&gt;第一部分为类名，如果用&lt;strong&gt;正体&lt;/strong&gt;书写，说明这是可以实例化的普通类；如果用&lt;strong&gt;斜体&lt;/strong&gt;书写，说明这是抽象类。&lt;/p&gt;
&lt;p&gt;第二部分为该类的属性，书写格式为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;可见性 属性名 ： 属性类型
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可见性有以下几种：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;可见性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;public&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;private&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;#&lt;/td&gt;
&lt;td&gt;protected&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;第三部分为该类的方法，书写格式为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;可见性 方法名（参数名1：参数类型1,...）：方法返回值类型
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;22-关系&#34;&gt;2.2 关系&lt;/h3&gt;
&lt;p&gt;类与类间共有常见的几种关系： 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation，组合(Composition)，依赖(Dependency)，下面对每种关系进行分析：&lt;/p&gt;
&lt;h4 id=&#34;221-泛化generalization&#34;&gt;2.2.1 泛化（Generalization)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;【泛化关系】&lt;/strong&gt;：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【箭头指向】&lt;/strong&gt;：带三角箭头的实线，箭头指向父类&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/cpp/UML%E7%B1%BB%E5%9B%BE/%E7%B1%BB%E5%9B%BE-02.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;222-实现realization&#34;&gt;2.2.2 实现（Realization）&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;【实现关系】&lt;/strong&gt;：是一种类与接口的关系，表示类是接口所有特征和行为的实现.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【箭头指向】&lt;/strong&gt;：带三角箭头的虚线，箭头指向接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/cpp/UML%E7%B1%BB%E5%9B%BE/%E7%B1%BB%E5%9B%BE-03.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;223-关联association&#34;&gt;2.2.3 关联（Association)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;【关联关系】&lt;/strong&gt;：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【代码体现】&lt;/strong&gt;：成员变量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【箭头及指向】&lt;/strong&gt;：带普通箭头的实心线，指向被拥有者&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/cpp/UML%E7%B1%BB%E5%9B%BE/%E7%B1%BB%E5%9B%BE-04.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图中，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。&lt;/p&gt;
&lt;p&gt;下图为自身关联：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/cpp/UML%E7%B1%BB%E5%9B%BE/%E7%B1%BB%E5%9B%BE-05.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;224-聚合aggregation&#34;&gt;2.2.4 聚合（Aggregation）&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;【聚合关系】&lt;/strong&gt;：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。&lt;/p&gt;
&lt;p&gt;聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【代码体现】&lt;/strong&gt;：成员变量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【箭头及指向】&lt;/strong&gt;：带空心菱形的实心线，菱形指向整体&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/cpp/UML%E7%B1%BB%E5%9B%BE/%E7%B1%BB%E5%9B%BE-06.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;225-组合composition&#34;&gt;2.2.5 组合(Composition)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;【组合关系】&lt;/strong&gt;：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。&lt;/p&gt;
&lt;p&gt;组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【代码体现】&lt;/strong&gt;：成员变量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【箭头及指向】&lt;/strong&gt;：带实心菱形的实线，菱形指向整体&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/cpp/UML%E7%B1%BB%E5%9B%BE/%E7%B1%BB%E5%9B%BE-07.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;226-依赖dependency&#34;&gt;2.2.6 依赖(Dependency)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;【依赖关系】&lt;/strong&gt;：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【代码表现】&lt;/strong&gt;：局部变量、方法的参数或者对静态方法的调用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【箭头及指向】&lt;/strong&gt;：带箭头的虚线，指向被使用者&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/cpp/UML%E7%B1%BB%E5%9B%BE/%E7%B1%BB%E5%9B%BE-08.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;各种关系的强弱顺序：
&lt;strong&gt;泛化 = 实现 &amp;gt; 组合 &amp;gt; 聚合 &amp;gt; 关联 &amp;gt; 依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面这张UML图，比较形象地展示了各种类图关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/cpp/UML%E7%B1%BB%E5%9B%BE/%E7%B1%BB%E5%9B%BE-09.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多重性(Multiplicity) :&lt;/strong&gt; 通常在&lt;strong&gt;关联、聚合、组合&lt;/strong&gt;中使用。就是代表有多少个关联对象存在。使用数字…星号（数字）表示。如下图，一个割接通知可以关联0个到N个故障单。&lt;/p&gt;
&lt;p&gt;重点讲一下聚合和组合的关系：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;聚合关系图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/cpp/UML%E7%B1%BB%E5%9B%BE/%E7%B1%BB%E5%9B%BE-10.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组合关系图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/cpp/UML%E7%B1%BB%E5%9B%BE/%E7%B1%BB%E5%9B%BE-11.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;从代码上看这两种关系的区别在于：&lt;/p&gt;
&lt;p&gt;构造函数不同&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;雁群类：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;  &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;GooseGroup&lt;/span&gt;  
&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;  
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Goose&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;goose&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  


    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;GooseGroup&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Goose&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;goose&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;  
    &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;  
    	&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;goose&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;goose&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;大雁类：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Goose&lt;/span&gt;  
&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;  
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Wings&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wings&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
  
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Goose&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;  
    &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;  
        &lt;span class=&#34;n&#34;&gt;wings&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Wings&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;  
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;  
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;聚合关系的类里含有另一个类作为参数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;雁群类&lt;/strong&gt;(GooseGroup)的构造函数中要用到大雁（Goose）作为参数把值传进来 大雁类（Goose）可以脱离雁群类而独立存在&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组合关系的类里含有另一个类的实例化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大雁类（Goose）在实例化之前 一定要先实例化翅膀类（Wings） 两个类紧密耦合在一起 它们有相同的生命周期 翅膀类（Wings）不可以脱离大雁类（Goose）而独立存在
信息的封装性不同
在聚合关系中，客户端可以同时了解雁群类和大雁类，因为他们都是独立的
而在组合关系中，客户端只认识大雁类，根本就不知道翅膀类的存在，因为翅膀类被严密的封装在大雁类中。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>【机器人学基础知识】10、运动学已经够用，为什么还要动力学</title>
      <link>https://littlethinking.cn/post/robotics/%E5%B9%B2%E8%B4%A7_10%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8A%A8%E5%8A%9B%E5%AD%A6/</link>
      <pubDate>Thu, 28 Jan 2021 14:03:23 +0800</pubDate>
      
      <guid>https://littlethinking.cn/post/robotics/%E5%B9%B2%E8%B4%A7_10%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8A%A8%E5%8A%9B%E5%AD%A6/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;本文为承上启下的一篇文章：一方面，我们很有必要把之前讲过的东西串起来过一遍；另一方面，在我们开始啃机械臂的动力学（dynamics）这块硬骨头之前，我们也很有必要弄明白“为什么需要研究机械臂的动力学？”这样一个问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们来看一个显示中的机器人，为了赏心悦目的需要，选择机械臂中的颜值担当UR5。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_10%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8A%A8%E5%8A%9B%E5%AD%A6/10_01UR5.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看到，UR5一共有六个R（旋转）关节，其中基座两个，肘部一个，腕部三个。现在如果需要写一段程序，完成两个任务：一个是&lt;strong&gt;把位于A点的物体捡起来并移动到B点&lt;/strong&gt;；二是&lt;strong&gt;在空中以一定的速度画圆&lt;/strong&gt;。假设我们能准确控制每个关节的位置，应当怎么做？&lt;/p&gt;
&lt;p&gt;我们需要做的第一件事情，就是&lt;strong&gt;确定关节零位，求正运动学解&lt;/strong&gt;。做该步骤的原因是，这是机械臂&lt;strong&gt;数字化、可编程化&lt;/strong&gt;的第一步。这一步，我们可以采用传统的DH参数法。关于采用DH参数法如何确定坐标系（frame attachment），请看文章&lt;a href=&#34;https://littlethinking.cn/post/robotics/%E5%B9%B2%E8%B4%A7_03dh%E5%BB%BA%E6%A8%A1/&#34;&gt;【机器人学基础知识】3、机械臂的坐标系与数学模型：传说中的DH参数&lt;/a&gt;。总之，在确定原点、确定Z轴、确定X轴等一系列步骤之后，我们得到类似下图的关节坐标系。（hint:RGB/红绿蓝对应XYZ）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_10%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8A%A8%E5%8A%9B%E5%AD%A6/10_02UR5%E5%9D%90%E6%A0%87%E7%B3%BB.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果我们还记得DH参数定义中关节角度θ的定义，当θ为0时，一个关节的X轴与上一个关节的X轴应该平行——上图正是如此。&lt;/p&gt;
&lt;p&gt;根据DH参数的定义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_10%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8A%A8%E5%8A%9B%E5%AD%A6/10_03DH%E5%8F%82%E6%95%B0%E5%AE%9A%E4%B9%89.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们在UR5的结构示意图标注出部分参数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_10%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8A%A8%E5%8A%9B%E5%AD%A6/10_04UR5DH%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;最后我们得到UR5的DH参数表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_10%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8A%A8%E5%8A%9B%E5%AD%A6/10_05UR5DH%E5%8F%82%E6%95%B0%E8%A1%A8.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;a与d怎么来的？通常来讲，它们是机械设计的时候确定的设计参数，机械臂的生产产家会告诉这些数值。当然，我们也可以自行在机械臂上测量出来&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;实际运用中，机械臂的制造厂商通常会将机械臂的DH参数表给我们；实在没有，也可以根据一些算法，根据控制关节运动的同时用外部装置准确测量end effector的位姿解算出DH参数表。有时候，由于制造过程中不可避免的误差、或长时间使用后机械结构的磨损，会导致原有的DH参数表不够准确；这个时候也可以用类似的方法重新标定机械臂的DH参数。对这部分感兴趣的小伙伴，可以查一下机械臂的&lt;strong&gt;Kinematics Model Identification 或 Kinematics Calibration&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于在本文前面提到的第一个任务：将一个物体从A点移动B点。对于这样一个任务，我们只需要机械臂在A点的时候能在对的位置以对的角度拿到物体、在B点以对的位置对的角度放下物体就好了。所以，一个比较合适的思路是：&lt;/p&gt;
&lt;p&gt;Ⅰ.计算A点与B点end effector理想位姿的逆运动学解（可以直接用解析大法几何大法等等）$q_a$，$q_b$&lt;/p&gt;
&lt;p&gt;Ⅱ.从$q_a$到$q_b$求出关节的运动轨迹&lt;/p&gt;
&lt;p&gt;Ⅲ.根据求出的轨迹，控制关节运动&lt;/p&gt;
&lt;p&gt;是不是很简单？这样的简单的“Pick and Place”应用，大概就是机械臂在工业上最早甚至也是最广泛的应用了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_10%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8A%A8%E5%8A%9B%E5%AD%A6/10_06%20pick%20and%20place.gif&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里再简单讲解下关节空间的&lt;strong&gt;轨迹生成（Trajectory Generation）&lt;/strong&gt;。需要注意的是，trajectory并不仅仅是空间中的一条线，它是&lt;strong&gt;物体位姿相对于时间的函数&lt;/strong&gt;，包含了物体每个时刻的位置、速度、加速度等信息。&lt;/p&gt;
&lt;p&gt;假设我们要求机械臂从A点到B点的时间为t&#39;，在A点与B点的时候end effector均为静止，那我们的轨迹q(t)应当满足这样的要求:
$$
q(0) = q_a, \ \ q(t&#39;) = q_b \\&lt;br&gt;
q&#39;(0) = 0 , \ \ q(t&#39;) = 0
$$
这个函数需要满足上面四个等式，则它至少需要有四个未知数；因此最直接的思路就是用一个三阶多项式来拟合：
$$
q(t) = at^3 + bt^2 +ct +d
$$&lt;/p&gt;
&lt;p&gt;关节空间的轨迹生成比起操作空间的轨迹生成简单许多，主要是可以方便地避免超出关节可运动范围或奇异状态等问题。以后有机会，我们再仔细讲讲trajectory generation这个话题。&lt;/p&gt;
&lt;p&gt;现在再看第二任务：在空中以一定速度画圆。这个任务本身已经规定了end effector的轨迹，而我们的任务是通过控制关节的运动让end effector能够跟随（track）这条轨迹。这样看来，我们很难再采用类似第一个任务那种方法。&lt;/p&gt;
&lt;p&gt;因为我们的任务是让end effector跟随一个圆形轨迹，也就是说，每一个时刻我们都要知道end effector 位姿$x_d$。我们说过，每时每刻都把逆运动学解直接求出来是一个不太现实的——这个时候，雅可比矩阵求逆法应该自然而然地进入我们脑海：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_10%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8A%A8%E5%8A%9B%E5%AD%A6/10_07%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6%E6%B1%82%E8%A7%A3%E6%80%9D%E8%B7%AF.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于这个方法不是很清楚的，请回去看&lt;a href=&#34;https://littlethinking.cn/post/robotics/%E5%B9%B2%E8%B4%A7_08%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6-%E4%BB%8E%E6%93%8D%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%88%B0%E5%85%B3%E8%8A%82%E7%A9%BA%E9%97%B4/&#34;&gt;【机器人学基础知识】8、“逆运动学”——从操作空间到关节空间（上篇）&lt;/a&gt;一文。&lt;/p&gt;
&lt;p&gt;这个任务相比“Pick and Place”难度提升了一些，但在工业应用中，加工、切割、喷涂等等，类似的应用也非常广泛。&lt;/p&gt;
&lt;p&gt;根据任务的不同，我们需要采用不同的解决方法。那么现在的问题是，什么样的任务只靠运动学无法解决好，而需要动力学加入呢？&lt;/p&gt;
&lt;p&gt;要回答这个问题，首先要明确动力学研究什么。机械臂的运动学，研究的是关节位置或位置变化与末端执行器位姿或位姿变化的关系，这里面只有“运动”，不涉及任何“动力”；由此可以想见，机械臂的动力学研究的必然与“动力”有关。所谓“动力”，指的是机械臂各部分受到的力或扭矩（我们以后统一用“力”指代“力或扭矩”）。机械臂的动力学，则是要研究下面几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;机械臂在运动过程中受到什么样地内力和外力？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;这些力怎么改变机械臂的运动状态？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关节受力与末端执行器的受力有什么关系？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为研究的是力，所以我们对机械臂的了解，在“关节的运动如何改变末端执行器的运动”以外又深入了一层，进入了“关节驱动器（actuator）产生的力如何改变关节的运动、从而改变end effector的运动”这个层面。也因此，我们将要控制的变量，也从关节的位置或速度，变成了关节的力。&lt;/p&gt;
&lt;p&gt;如果你有准确的动力学模型，你就能够准确控制关节的加速度，从而准确控制end effector的加速度。我们知道，位置是加速度对时间的两次积分，这意味着，直接控制加速度允许你对轨迹做更精确快速的跟踪。&lt;/p&gt;
&lt;p&gt;对上面所说的第二个任务，如果要求画圆的速度很快，雅可比矩阵求逆法d~x~不能过大的要求马上就不能满足了。即使忽略这个限制，关节位置控制器由于对它所要控制的对象的动力学一无所知，也很难快速地跟上end effector圆形轨迹需要的关节轨迹。结果是什么呢？机械臂可能会抖得很厉害、画出来的圆会比实际的小且不那么圆、甚至end effector只能在原地振动。&lt;/p&gt;
&lt;p&gt;如果看不太明白上面这一段话也没有关系，我们以后会详细讲机械臂的各种控制方法。但是可以理解的一点是，&lt;strong&gt;动力学的引入允许我们更快、更精确地跟随需要的轨迹&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;给大家看看舵机做的只用逆运动学的机械臂和工业级的用于做精确激光切割的机械臂画圆的区别——&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_10%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8A%A8%E5%8A%9B%E5%AD%A6/10_08%E5%8F%AA%E7%94%A8%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6.gif&#34; alt=&#34;2&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_10%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8A%A8%E5%8A%9B%E5%AD%A6/10_09%E5%B7%A5%E4%B8%9A%E7%BA%A7.gif&#34; alt=&#34;3&#34;&gt;&lt;/p&gt;
&lt;p&gt;但工业级械臂更庞大：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_10%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8A%A8%E5%8A%9B%E5%AD%A6/10_10%E7%BA%BF%E5%88%87%E5%89%B2%E5%B7%A5%E4%B8%9A%E6%9C%BA%E6%A2%B0%E8%87%82.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;现在，我们有最后一个任务，让end effector去打磨一个零件——拿一把锉刀靠近零件然后来回运动并不足够，你还需要能够控制锉刀对零件施加一定的力。很明显，涉及到接触力，单纯用运动学也是无法解决的。&lt;strong&gt;动力学的引入让我们有可能控制机械臂与外界的相互作用力&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这篇文章没有太多新的知识，这可能也是任何课本都不会有的章节；但我觉得它很重要。首先，在学完了逆运动学之后，你已经可以尽情地去用Arduino和舵机等等DIY自己的机械臂，尝试不同的逆运动学算法，让它完成搬东西、画画等各种好玩的任务。然而你也要明白，在Robotics的世界里，这只是入门的一步。没有动力学加入控制回路的机器人能做的事情非常有限，它们速度无法做到很快、负载不能做很重、如果功率很大会非常危险。明白了这些，我们才不会在学习复杂的机械臂动力学时不知所以然。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>【机器人学基础知识】9、“逆运动学”——从操作空间到关节空间（下篇）</title>
      <link>https://littlethinking.cn/post/robotics/%E5%B9%B2%E8%B4%A7_09%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6-%E4%BB%8E%E6%93%8D%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%88%B0%E5%85%B3%E8%8A%82%E7%A9%BA%E9%97%B4%E4%B8%8B%E7%AF%87/</link>
      <pubDate>Tue, 26 Jan 2021 14:03:23 +0800</pubDate>
      
      <guid>https://littlethinking.cn/post/robotics/%E5%B9%B2%E8%B4%A7_09%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6-%E4%BB%8E%E6%93%8D%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%88%B0%E5%85%B3%E8%8A%82%E7%A9%BA%E9%97%B4%E4%B8%8B%E7%AF%87/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;逆运动学，就是&lt;strong&gt;从操作空间的end effector position and orientation,求关节空间的joint position&lt;/strong&gt;的问题。在上一篇文章中，我们简单提到求逆运动学解的解析解法和优化解法，详细讲解了用逆瞬时（或说微分）运动学即雅可比矩阵法迭代求解逆运动学的方法。这篇文章我们继续讲雅可比矩阵求逆法存在的问题、用以对付Singularity问题的阻尼最小平方法，并详细地讲讲雅可比矩阵转置法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1-雅可比矩阵求逆法&#34;&gt;1 雅可比矩阵求逆法&lt;/h3&gt;
&lt;h4 id=&#34;11-原理&#34;&gt;1.1 原理&lt;/h4&gt;
&lt;p&gt;雅可比矩阵求逆法，就是利用下面式子所示的关节速度与end effector速度的关系，迭代求解逆运动学问题的方法。
$$
\dot{x} = J \dot{q} \Rightarrow \dot{q} = J^{-1} \dot{x}
$$
我们可以用一个控制框图来表示这个求解过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_09%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6-%E4%BB%8E%E6%93%8D%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%88%B0%E5%85%B3%E8%8A%82%E7%A9%BA%E9%97%B4(%E4%B8%8B)/9_01%E9%9B%85%E5%8F%AF%E6%AF%94%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86%E6%B3%95%E6%A1%86%E5%9B%BE.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这个方法把复杂的逆运动学运算（解析法和优化法）转化为求解线性方程的运算，具有很好的通用性；然而这个方法也存在一些问题。&lt;/p&gt;
&lt;h4 id=&#34;12-雅可比矩阵求逆法存在的问题&#34;&gt;1.2 雅可比矩阵求逆法存在的问题&lt;/h4&gt;
&lt;p&gt;从原理上讲，使用这个方法最明显的一点要求是——&lt;strong&gt;dx不能过大&lt;/strong&gt;。因为Jacobian是随着关节位置变化不断在变化的，一旦关节位置变化很大，算出来的Jacobian Inverse就不再准确了。这个问题通常我们可以用轨迹线性插值（linear interpolation）或限制dx的大小（clamping）来避免。&lt;/p&gt;
&lt;p&gt;这个方法的第二个难点是雅可比矩阵求逆运算。&lt;strong&gt;矩阵求逆是一个非常消耗计算资源的运算&lt;/strong&gt;（在写程序时能避免就绝对不要求逆！）。当然，我们总是可以使用各种各样的解线性方程的方法来避开求逆运算，比如LU分解、Chelosky分解、QR分解、SVD（Singular Value Decomposition）等等——这个以后也可以考虑用来填几篇干货了……&lt;/p&gt;
&lt;p&gt;这个方法最大的问题还是在于它&lt;strong&gt;无法很好地对付机器人Singularity或接近Singularity的情况&lt;/strong&gt;。从线性方程的角度看，当机器人接近Singularity时，雅可比矩阵也越来越“病态”（ill-conditioned），很小的dx可能求得很大的dq，方程对数值误差也更加敏感；而当机器人处于Singularity时，线性方程可能无解、也可能有无数多个解。&lt;/p&gt;
&lt;p&gt;下面的动图展示了控制机械臂运动轨迹通过两种常见的Singularity Configuration的情况，可以帮助你理解什么叫“接近Singularity时，很小的dx可能得到很大的dq”。(图中end effector走直线轨迹，它停顿的那一点就是机械臂处于singularity的点，可以看到在那个点关节突然快速运动）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_09%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6-%E4%BB%8E%E6%93%8D%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%88%B0%E5%85%B3%E8%8A%82%E7%A9%BA%E9%97%B4(%E4%B8%8B)/9_02WristSingularity.gif&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_09%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6-%E4%BB%8E%E6%93%8D%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%88%B0%E5%85%B3%E8%8A%82%E7%A9%BA%E9%97%B4(%E4%B8%8B)/9_03ShoulderSingularity.gif&#34; alt=&#34;2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-dlsdamped-least-square阻尼最小平方法&#34;&gt;2 DLS（Damped Least Square，阻尼最小平方法）&lt;/h3&gt;
&lt;p&gt;为了避免利用雅可比矩阵求逆法控制机械臂时由于接近Singularity而产生非常大的关节速度，一个自然的想法就是在求解过程中限制关节速度——&lt;strong&gt;既要尽可能地满足方程条件、也要尽可能地让关节速度不要太大&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于前者，我们可以用最小平方法求解方程，这时问题可以这样表述：
$$
\min_{\dot{q} } {\Vert{J\dot{q}} - \dot{x} \Vert}^2
$$
即求一个dq，使得$Jdq-dx$的norm(向量范数，可以理解为均衡向量距离的一种指标)的平方最小；理想情况下，这个norm等于0。&lt;/p&gt;
&lt;p&gt;对于后者，即是希望||dq||尽可能小（但显然通常情况下不能为0），此时我们可以把上面的式子后面再加一个“阻尼”项，变成这样：
$$
\min_{\dot{q} } {\Vert{J\dot{q}} - \dot{x} \Vert}^2 + \lambda^2{\Vert{\dot{q}} \Vert}^2
$$
即求一个dq，使$Jdq-dx$的norm的平方，加上乘以一个系数的dq的norm的平方，它们的和最小。这个时候，λ的大小决定了你更“看重”哪一个条件：如果λ很大，那可能你求得一个很小的关节运动速度，但这个速度却不能准确地让end effector按照你所希望的轨迹走；如果λ很小，小到接近于0，那这个方法跟之前的最基础的Jacobian Inverse算法也没有什么两样了。在实际使用，λ的大小往往需要仔细选择。&lt;/p&gt;
&lt;p&gt;求解上面那个式子的最小值，还是用我们伟大的&lt;strong&gt;导数求极值法&lt;/strong&gt;：
$$
\begin{align}
\frac{d{\Vert {J\dot{q}} - \dot{x} \Vert}^2 + \lambda^2{\Vert{\dot{q}} \Vert}^2}{d\dot{q}} 
&amp;amp;= \frac{d({J\dot{q}} - \dot{x})^T({J\dot{q}} - \dot{x}) + \lambda^2 \dot{q}^T \dot{q}}{d\dot{q}} \\&lt;br&gt;
&amp;amp;= \frac{d\dot{q}^TJ^TJ\dot{q} - \dot{x}^TJ\dot{q} - \dot{q}^TJ^T\dot{x}+\dot{x}^T\dot{x}+\lambda^2\dot{q}^T\dot{q}}{d\dot{q}} \\&lt;br&gt;
&amp;amp;= 2J^TJ\dot{q} - 2J^T\dot{x} + 2\lambda^2I\dot{q} = 0
\end{align}
$$
（这么详细的求导过程就算看不懂也要记住啊！极其重要，随处可见）&lt;/p&gt;
&lt;p&gt;于是我们得到一个等效方程：
$$
(J^TJ+\lambda^2I)\dot{q} = J^T\dot{x}
$$
左边的系数矩阵是可逆的(数学好的人可以尝试证明下)，于是我们就有了解：
$$
\dot{q} = (J^TJ+\lambda^2I)^{-1}J^T\dot{x}
$$
同时也可得以下等式：
$$
\dot{q} = (J^TJ+\lambda^2I)^{-1}J^T\dot{x} = J^T(JJ^T+\lambda^2I)^{-1}\dot{x}
$$
知道这个有什么用呢？因为左边需要求逆的矩阵大小为n×n，n为关节数量，要多大有多大；右边需要求逆的矩阵大小为m×m，m为操作空间的自由度大小，最大肯定不超过六。这个小小的转换，就限制了需要求逆运算的矩阵大小，提高了总体的运算速度。&lt;/p&gt;
&lt;h3 id=&#34;3-雅可比矩阵转置法&#34;&gt;3 雅可比矩阵转置法&lt;/h3&gt;
&lt;p&gt;上次我们简单地讲到说，我们可以用雅可比矩阵的转置代替求逆运算来求逆运动学问题：
$$
\dot{q} = J^T\dot{x}
$$
今天我们详细地讲下这个看起来很随便的方法是怎么推导出来的。&lt;/p&gt;
&lt;p&gt;首先明确求解逆运动学问题，我们的终极目标是控制机械臂的各个关节，让机械臂的end effector运动到我们想要它到达的位置及朝向。我们把这个“理想位置”计为$x_d$，我们的目标就是要让当前end effector位置$x_c$与$x_d$的“距离”最短。于是我们又有了一个数学问题：
$$
\min_{q}\frac{1}{2} {\Vert x_d - x_c \Vert}^2
$$
注意上面式子中我们要求的是q，而不是dq。乘上1/2是为了求导后不要有讨厌的系数2。&lt;/p&gt;
&lt;p&gt;用正运动学的表达式可以把$x_c$用$f(q)$表示：
$$
\min_{q}\frac{1}{2} {\Vert x_d - f(q)\Vert}^2
$$
（也许你已经发现了这个就是把逆运动学转化为优化问题的**优化法**）。&lt;/p&gt;
&lt;p&gt;由于正运动学的表达式f(q)通常比较复杂，导数极值法在这里不太好用。所以我们祭出求极值的另一个伟大工具：&lt;strong&gt;梯度下降法（Gradient Descent）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;梯度下降法说，每一步我都要沿着下降最快的那个方向走，而这个方向可以由梯度的反方向求得，所以我们有：
$$
\begin{align}
\Delta q &amp;amp;= -\alpha \nabla(\frac{1}{2}{\Vert x_d - f(q)\Vert}^2 ) \\&lt;br&gt;
&amp;amp;= \alpha \Bigg(  (x_d-x)^T \frac{\partial f(q)}{\partial q}  \Bigg)^T \\&lt;br&gt;
&amp;amp;= \alpha J^T(x_d-x) = \alpha J^T \Delta x
\end{align}
$$
这个推导证明了如果我们用梯度下降大法，每一步都用J的转置乘dx求出dq，那么机械臂迭代几步以后end effector将无限趋近指定的$x_d$。它的迭代框图其实与雅可比矩阵求逆法是一样的，只是$J^{-1}$换成了$J^T$。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_09%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6-%E4%BB%8E%E6%93%8D%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%88%B0%E5%85%B3%E8%8A%82%E7%A9%BA%E9%97%B4(%E4%B8%8B)/9_04%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95%E6%B1%82%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;上面的α也是梯度下降法的一个系数，叫“步长”（step size）或“学习速率”（learning rate)。这个值太小，则迭代速度可能太慢；这个值太大，则可能“走过头”或要多绕一些弯路，最终还是使迭代速度变慢（甚至无法收敛到最小值）。&lt;/p&gt;
&lt;p&gt;采用雅可比矩阵转置而不是求逆的方法，最大的好处当然是避免了求逆运算；不过与求逆相比，它的迭代收敛速率反而慢些。另外，用这个方法控制的机械臂，离end effector较远的关节常常需要输出更大的扭矩。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;关于逆运动学的这两篇文章，可以说讲了机器人学家们与逆运动学问题斗智斗勇的过程；我们简单提到解析法和优化法，讲了雅可比矩阵求逆迭代法、阻尼最小平方法、以及实质上也是优化和迭代方法的雅可比矩阵转置法。然而这只是逆运动学问题求解方法中比较有代表性的一小部分。&lt;/p&gt;
&lt;p&gt;最后我想说，我们用到的&lt;strong&gt;向量求导、导数极值法、拉格朗日乘数法、梯度下降法&lt;/strong&gt;等，都是非常重要非常有用的数学工具。相信通过对逆运动学问题解法的学习研究，你的数学水平也得到了提高……&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>【机器人学基础知识】8、“逆运动学”——从操作空间到关节空间（上篇）</title>
      <link>https://littlethinking.cn/post/robotics/%E5%B9%B2%E8%B4%A7_08%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6-%E4%BB%8E%E6%93%8D%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%88%B0%E5%85%B3%E8%8A%82%E7%A9%BA%E9%97%B4/</link>
      <pubDate>Sun, 24 Jan 2021 14:03:23 +0800</pubDate>
      
      <guid>https://littlethinking.cn/post/robotics/%E5%B9%B2%E8%B4%A7_08%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6-%E4%BB%8E%E6%93%8D%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%88%B0%E5%85%B3%E8%8A%82%E7%A9%BA%E9%97%B4/</guid>
      
        <description>&lt;h3 id=&#34;0-复习&#34;&gt;0 复习&lt;/h3&gt;
&lt;p&gt;机器人学基础知识已经完成第8篇了，这里梳理下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;入门&lt;/strong&gt;：如果不清楚R关节与P关节，建议再去看第一篇文章&lt;a href=&#34;https://littlethinking.cn/post/robotics/%E5%B9%B2%E8%B4%A7_01%E4%BB%8Erp%E5%85%B3%E8%8A%82%E5%85%A5%E9%97%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/&#34;&gt;【机器人学基础知识】1、从RP关节入门机器人学&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重要背景知识&lt;/strong&gt;：如果不清楚w.r.t frame{0}、旋转矩阵、齐次坐标变换等，建议再去看第二篇文章&lt;a href=&#34;https://littlethinking.cn/post/robotics/%E5%B9%B2%E8%B4%A7_02%E4%BD%8D%E7%BD%AE%E8%A7%92%E5%BA%A6%E5%B9%B3%E7%A7%BB%E6%97%8B%E8%BD%AC%E4%BB%A5%E5%8F%8A%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/&#34;&gt;【机器人学基础知识】2、位置角度平移旋转，“乱七八糟”的坐标变换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DH参数是啥&lt;/strong&gt;？&lt;strong&gt;从关节空间的关节位置（关节位置又是啥！说不出来要面壁了）如何求出操作空间的end effector position/orientation&lt;/strong&gt;？不清楚这些概念，可以再浏览下&lt;a href=&#34;https://littlethinking.cn/post/robotics/%E5%B9%B2%E8%B4%A7_03dh%E5%BB%BA%E6%A8%A1/&#34;&gt;【机器人学基础知识】3、机械臂的坐标系与数学模型：传说中的DH参数&lt;/a&gt;与&lt;a href=&#34;https://littlethinking.cn/post/robotics/%E5%B9%B2%E8%B4%A7_04%E6%AD%A3%E8%BF%90%E5%8A%A8%E5%AD%A6-%E4%BB%8E%E5%85%B3%E8%8A%82%E7%A9%BA%E9%97%B4%E5%88%B0%E6%93%8D%E4%BD%9C%E7%A9%BA%E9%97%B4/&#34;&gt;【机器人学基础知识】4、机械臂的坐标系与数学模型：传说中的DH参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;从关节空间的关节速度怎么求出操作空间的end effector速度&lt;/strong&gt;？？不清楚这些概念，可以再浏览下&lt;a href=&#34;https://littlethinking.cn/post/robotics/%E5%B9%B2%E8%B4%A7_05%E7%9E%AC%E6%97%B6%E8%BF%90%E5%8A%A8%E5%AD%A6/&#34;&gt;【机器人学基础知识】5、“瞬时运动学”——还是从关节空间到操作空间&lt;/a&gt;、&lt;a href=&#34;https://littlethinking.cn/post/robotics/%E5%B9%B2%E8%B4%A7_06%E6%80%8E%E4%B9%88%E6%B1%82%E9%9B%85%E5%8F%AF%E6%AF%94%E7%9F%A9%E9%98%B5/&#34;&gt;【机器人学基础知识】6、机械臂的雅可比矩阵这么厉害，怎么把它求出来呢？&lt;/a&gt;以及&lt;a href=&#34;https://littlethinking.cn/post/robotics/%E5%B9%B2%E8%B4%A7_07%E9%9B%85%E5%8F%AF%E6%AF%94%E7%9F%A9%E9%98%B5%E7%BB%88%E7%AF%87/&#34;&gt;【机器人学基础知识】7、力的传递关系、奇异、冗余——从雅可比矩阵你还能得到什么？(雅可比矩阵下篇)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-逆运动学inverse-kinematics&#34;&gt;1 逆运动学（Inverse Kinematics）&lt;/h3&gt;
&lt;p&gt;有了前面的铺垫，理解逆运动学所研究的问题就变得非常简单了——我要求我的end effector运动到某一个位置朝向某一个方向（比如我要控制我的手去拿一杯水），此时我的手臂各个关节应该运动到哪个关节位置呢？这个问题显然是机器人学需要研究的一个根本问题——因为对于任意机械臂，&lt;strong&gt;你想控制的量在操作空间，而你能控制的量却在关节空间&lt;/strong&gt;。想要控制end effector在操作空间完成特定操作，就一定避不开逆运动学这个问题。&lt;/p&gt;
&lt;p&gt;逆运动学最基本的思路，是从正运动学反过来，比如以我们最熟悉的RR平面机械臂为例&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_08%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6-%E4%BB%8E%E6%93%8D%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%88%B0%E5%85%B3%E8%8A%82%E7%A9%BA%E9%97%B4/8_01RR%E6%9C%BA%E6%A2%B0%E8%87%82.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;它的逆运动学问题是：已知操作空间$(x_e,y_e)$，怎么求关节空间$(\theta_1,\theta_2)$？&lt;/p&gt;
&lt;p&gt;很明显我们有两个未知数、两个方程，解解方程就行了。当然，这明显是一个&lt;strong&gt;非线性方程组&lt;/strong&gt;，怎么解？我是把两个等式都两边平方然后相加，可以求出$\theta_2$，然后再求出$\theta_1$。&lt;/p&gt;
&lt;p&gt;如果是一个六自由度的机械臂，我们用包含关节位置的Transformation Matrix（齐次坐标变换矩阵）来表示end effector的位置和朝向，这个矩阵包含了end effector position w.r.t {0}（一个3×1的向量），以及end effector的旋转矩阵w.r.t {0}（一个3×3的矩阵），一共12个未知数，这时候逆运动学又怎么求呢？&lt;/p&gt;
&lt;p&gt;如果是一个七自由度的机械臂，我们说这时候机械臂存在冗余自由度，end effector固定不动的时候关节仍然可以运动，这时候逆运动学又怎么求呢？&lt;/p&gt;
&lt;p&gt;由于逆运动学非线性、解不一定存在或不是唯一等特性，比起正运动学直截了当的写矩阵，求解逆运动学就要困难得多，也因此有很多不同的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;解析法&lt;/strong&gt;（Analysis Solution），顾名思义是&lt;strong&gt;用代数或几何大法直接求解&lt;/strong&gt;，如上面的例子所示。通常随着自由度上升，求得解析解的难度也越来越大，对于冗余机械臂还需要从几个解中选择合适的解。这种方法通常用在特定几何结构的机械臂，并且有特定的关节位置求解顺序。这里有一个视频，展示了一个六自由度KUKA KR 60机械臂的解析解求解方法，&lt;a href=&#34;https://v.qq.com/x/page/k1304y06jf4.html&#34;&gt;视频链接&lt;/a&gt;。由于解析解法不具有通用性，我们后面不再详述。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优化法&lt;/strong&gt;（Optimization-based Solution），是&lt;strong&gt;把问题转化为一个优化问题求数值解&lt;/strong&gt;。用数学语言表达，就是把求
$$
q = f^{-1}(x)
$$&lt;/p&gt;
&lt;p&gt;的问题，转化为&amp;quot;求关节位置q，使实际end effector位置x与正运动学算出的end effector位置发f(q)之间的差值最小&amp;quot;的问题：
$$
\min_q,where \ e = {(x - f(q))}^2
$$
如何求解上面这个式子（比如用梯度下降大法Gradient Descent）就是一个数学问题了，所以本文也不再详述。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;迭代解 - 雅可比矩阵求逆法&lt;/strong&gt;（Iterative Method - Jacobian Inverse），是把问题“微分化”，利用瞬时运动学的逆运算无限逼近
$$
\dot{x} = J \dot{q} \Rightarrow \dot{q} = J^{-1} \dot{x}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;雅可比矩阵转置法&lt;/strong&gt;（Jacobian Transpose），是从下面式子出发，用雅可比矩阵的转置代替困难的求逆运算
$$
\tau = J^TF
$$
由于在逆运动学求解中，我们不关心系统的动力学特性，上面这个式子也可以写成
$$
\dot{q} = J^T \dot{x}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面这两个方法相对比较通用（是否工业上常用？这个很难说。可能工业上对特定机械臂用解析解的也不少……），所以这篇文章主要还是给我们的老朋友雅可比矩阵解锁新功能，本文将着重介绍雅可比矩阵求逆法。&lt;/p&gt;
&lt;h3 id=&#34;2-迭代解-雅可比矩阵求逆jacobian-inverse&#34;&gt;2 迭代解-雅可比矩阵求逆（Jacobian Inverse）&lt;/h3&gt;
&lt;p&gt;雅可比矩阵求逆的方法有什么优点呢？我们还是拿那个两自由度机械臂举例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_08%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6-%E4%BB%8E%E6%93%8D%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%88%B0%E5%85%B3%E8%8A%82%E7%A9%BA%E9%97%B4/8_02RR%E6%9C%BA%E6%A2%B0%E8%87%82J%E6%B1%82%E9%80%86.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;假设link的长度都是1，那我们可以求出它的解析解为：
$$
\theta_2 = {\cos}^{-1} \frac{x^2 + y^2 - 2}{2} \\&lt;br&gt;
\theta_1 = \frac{-x \sin\theta_2 + y \cos\theta_2 + y}{y \sin\theta_2 + x \cos\theta_2 +x}
$$
现在我们需要end effector从图中$(x_e,y_e)$沿紫色直线运动到$(x&#39;_e,y&#39;_e)$，但需要控制关节位置实现这一点。现在有以下思路——&lt;/p&gt;
&lt;p&gt;Ⅰ.求起点和终点对应的关节位置，直接对这两处关节位置进行线性插值求得关节运动轨迹——这样虽然省了很多计算量，但end effector&lt;strong&gt;不大可能沿着直线走&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;Ⅱ.把这条直线插入很多很多中间点，&lt;strong&gt;每一个点都求出对应的关节位置&lt;/strong&gt;，然后控制每一个关节按着这一系列的关节位置走（就是我们前面说的解析/优化解法）；&lt;/p&gt;
&lt;p&gt;Ⅲ.还是把这条直线插入很多很多中间点，但如果&lt;strong&gt;点与点的间隔足够小、运动时间足够短&lt;/strong&gt;，我们就可以在每一点&lt;strong&gt;用雅可比矩阵求逆来求得当前关节位置的变化&lt;/strong&gt;——换个角度讲，我们也可以设定end effector沿这条直线的运动速度，用雅可比矩阵求逆求得关节速度，&lt;strong&gt;直接控制关节的运动速度而不是位置&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们将第三个方法画成控制框图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_08%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6-%E4%BB%8E%E6%93%8D%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%88%B0%E5%85%B3%E8%8A%82%E7%A9%BA%E9%97%B4/8_03%E6%96%B9%E6%B3%95%E4%B8%89%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;图中$x_d$的&lt;strong&gt;下标d表示“desired”&lt;/strong&gt;，即你希望x到达的位置和朝向；以后还有&lt;strong&gt;下标c表示“current”&lt;/strong&gt;，即当前x的位置/朝向；我们会经常看到这样的下标。&lt;/p&gt;
&lt;p&gt;你可能不懂控制框图，没关系，首先上面一行Joint control（关节控制）之前，从左到右说的是：
$$
dx = x_d - x \\&lt;br&gt;
dq = J^{-1}dx \\&lt;br&gt;
q_d = dq + q_c
$$
Joint control则是你把你计算出来的$q_d$送到每一个关节的控制器中（比如最简单的舵机）；这些控制器最终把各个关节控制到位置q（好的控制器，大部分情况q和$q_d$应当非常接近）&lt;/p&gt;
&lt;p&gt;这个图的下边一行说的是，我们又从这个关节位置q用正运动学求出了此时的end effector位置x，反馈到前面再给上面第一个式子运算求dx。&lt;/p&gt;
&lt;p&gt;通常你设置一个$x_d$，控制器需要走几遍这个控制回路才能将dx降到接近0（让x逼近$x_d$），因此这个方法也被称为迭代法。&lt;/p&gt;
&lt;h3 id=&#34;3-冗余雅可比矩阵求逆&#34;&gt;3 冗余雅可比矩阵求逆&lt;/h3&gt;
&lt;p&gt;你一定想问，当雅可比矩阵不可求逆的时候怎么办呢？不可求逆的情况有很多种，我们这里先讨论一种：即当雅可比矩阵是矮胖型，机械臂具有冗余自由度的情况。&lt;/p&gt;
&lt;p&gt;这个时候要用到一个数学概念，叫&lt;strong&gt;伪逆矩阵（pseudoinverse）&lt;/strong&gt;。伪逆矩阵也有很多种，在机器人逆运动学中用得较多的是&lt;strong&gt;右伪逆矩阵（right-inverse）&lt;/strong&gt;。如果把伪逆矩阵记为A+，left-inverse是说(A+)A = I；而right-inverse就是说A(A+) = I。&lt;/p&gt;
&lt;p&gt;Right-inverse是通过求解下面这个问题得到的：
$$
\min_{\dot{q}} {\Vert{\dot{q}} \Vert}^2 \\&lt;br&gt;
subject \ to  \ \dot{x} = J\dot{q}
$$
在机器人中，我们会希望每一次迭代的关节运动量尽可能小（从多种可能的运动方式中选出运动最少的一种），所以上面说的是**求一个尽可能小的能满足方程的dq**&lt;/p&gt;
&lt;p&gt;用&lt;strong&gt;拉格朗日乘数法（Lagrange Multiplier）&lt;/strong&gt;,这个问题可以变成：
$$
\min_{\dot{q}} \frac{1}{2}{\Vert{\dot{q}} \Vert}^2 + \lambda^T(\dot{x} - J\dot{q})
$$
（乘1/2是为了后面求导后不要有个讨厌的2——不影响结果）&lt;/p&gt;
&lt;p&gt;拉格朗日乘数法是一个求约束条件下极值的方法，非常有用，用起来也比较简单，而且我们以后还会用到——如果你不是很了解，我强烈建议你去自学一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要求极值，必先求导&lt;/strong&gt;——拉格朗日乘数法是分别对dq和$\lambda$求导，导数为0时可求得极值（我们就不论证这里是极小值了）：
$$
\frac{d\frac{1}{2}{\Vert{\dot{q}} \Vert}^2 + \lambda^T(\dot{x} - J\dot{q})}{d\dot{q}} = \dot{q}^T - \lambda^TJ = 0 \\&lt;br&gt;
\frac{d\frac{1}{2}{\Vert{\dot{q}} \Vert}^2 + \lambda^T(\dot{x} - J\dot{q})}{d\lambda} = \dot{x} - J\dot{q} = 0
$$
解上面两个方程，即可求出
$$
\dot{q} = J^T \lambda \\&lt;br&gt;
\dot{x} = J\dot{q} = JJ^T\lambda \stackrel{solve \ \lambda}{\Longrightarrow}  \ \lambda = (JJ^T)^{-1} \dot{x} \\&lt;br&gt;
\dot{q} = J^T(JJ^T)^{-1}\dot{x} \\&lt;br&gt;
\therefore J^{+} = J^T(JJ^T)^{-1}
$$
不难验证$JJ^+=I$。用这个$J^+$求解出的dq即为满足条件的最小关节运动速度。最后简单地提一下null space，我们可以验证：
$$
\forall \dot{q},J(I-J^{+}J)\dot{q}_0 = 0
$$
这说明矩阵$I-J^+J$可以把任意关节速度投影到“零空间”内，投影后的关节速度将不引起任何end effector的运动。利用这个特性，我们可以在满足了end effector的$x_d$之后，再利用零空间实现其它任务（比如避开障碍物）。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;为了不一下子扔太多东西，这篇文章就到此为止吧。下一篇文章我们会讲雅可比矩阵求逆法存在的问题和解决方法、雅可比矩阵转置法、再酌情提一些其它的逆运动学求解算法。说起来，逆运动学这个问题真是麻烦得不行，解法也是五花八门呢……&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>【机器人学基础知识】7、力的传递关系、奇异、冗余——从雅可比矩阵你还能得到什么？(雅可比矩阵下篇)</title>
      <link>https://littlethinking.cn/post/robotics/%E5%B9%B2%E8%B4%A7_07%E9%9B%85%E5%8F%AF%E6%AF%94%E7%9F%A9%E9%98%B5%E7%BB%88%E7%AF%87/</link>
      <pubDate>Sun, 17 Jan 2021 14:03:23 +0800</pubDate>
      
      <guid>https://littlethinking.cn/post/robotics/%E5%B9%B2%E8%B4%A7_07%E9%9B%85%E5%8F%AF%E6%AF%94%E7%9F%A9%E9%98%B5%E7%BB%88%E7%AF%87/</guid>
      
        <description>&lt;h3 id=&#34;0-回顾&#34;&gt;0 回顾&lt;/h3&gt;
&lt;p&gt;这是关于雅可比矩阵的第三篇文章。我们回顾下前面的内容，雅可比矩阵从何而来、如何求之。&lt;/p&gt;
&lt;p&gt;首先我们在学习&lt;strong&gt;正运动学&lt;/strong&gt;——即如何&lt;strong&gt;将关节空间的位置映射到操作空间的位置及朝向&lt;/strong&gt;这个问题之后，第二个问题就是瞬时运动学——&lt;strong&gt;如何将关节空间的速度映射到操作空间的速度&lt;/strong&gt;。经过推导，我们发现，雅可比矩阵就是解出这个映射的关键:
$$
\dot{x} = J \dot{q}
$$
其中，
$$
J = \begin{bmatrix}
\frac{dx_1}{dq_1} &amp;amp; \dots &amp;amp; \frac{dx_1}{dq_n} \\&lt;br&gt;
\vdots &amp;amp; \ddots &amp;amp; \vdots \\ 
\frac{dx_m}{dq_1} &amp;amp; \dots &amp;amp; \frac{dx_m}{dq_n} 
\end{bmatrix}
$$
雅可比矩阵有m行n列:&lt;strong&gt;m为操作空间的自由度，n为关节空间的自由度&lt;/strong&gt;（或说关节数量）。&lt;/p&gt;
&lt;p&gt;基本雅可比矩阵（Basic Jacobian）是&lt;strong&gt;由笛卡尔坐标描述操作空间线速度及角速度求得&lt;/strong&gt;，可分为两部分：线速度雅可比矩阵$J_v$和角速度雅可比矩阵$J_w$，分别求解。
$$
J = \begin{bmatrix}
J_v \\&lt;br&gt;
J_w
\end{bmatrix}
$$
求解基本雅可比矩阵需要先求解正运动学。一个链式机械臂的$J_v$由end effector的位置对关节位置求导得到；$J_v$由每一个旋转关节的旋转轴单位向量得到——具体求解方法请复习上一篇。理解这个简单的求解方法对理解雅可比矩阵大有益处！&lt;/p&gt;
&lt;p&gt;回顾完毕，现在我们可以来和雅可比矩阵进行一场更深入的交流……&lt;/p&gt;
&lt;h3 id=&#34;1-力传递force-relationship&#34;&gt;1 力传递（Force relationship）&lt;/h3&gt;
&lt;p&gt;在研究了关节空间与操作空间的位置映射关系和速度关系以后，我们继续思考：那么它们的&lt;strong&gt;力/扭矩映射关系&lt;/strong&gt;又如何？举例说明——如果别人抓着你的手用力想把它从你戳红包的屏幕上移开，你的肩膀、手肘、手腕等各处关节（这里假设身体的其他部分没有作用且固定了）各自需要输出多大的力矩才能让你的手保持不动呢？如果你要锤击一个沙包，它们又需要输出多大的扭矩呢？&lt;/p&gt;
&lt;p&gt;很神奇的是，&lt;strong&gt;雅可比矩阵同样也是连接关节空间与操作空间力/扭矩映射关系的纽带。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在我们设在关节空间，关节输出的力/扭矩为:
$$
\tau = {[\tau_1 \quad \tau_2 \quad \dots \quad \tau_n]}^T
$$
关节运动速度为
$$
\dot{q} =  {[\dot{q}_1 \quad \dot{q}_2 \quad \dots \quad \dot{q}_n]}^T
$$
注意我们使用的始终是列向量（这是在第二篇文章中就约好了的^o^）。&lt;/p&gt;
&lt;p&gt;那么整个系统输出的功率（等于力乘速度）在关节空间即表示为
$$
P = {\tau}^T \dot{q}
$$
希望你一眼就明白这是个&lt;strong&gt;向量点乘&lt;/strong&gt;，P显然是一个标量……&lt;/p&gt;
&lt;p&gt;现在从操作空间的角度看，设此时end effector能够对外界输出的力/扭矩（或说为了&lt;strong&gt;维持整个系统的静态平衡&lt;/strong&gt;，外界对end effector的作用力/扭矩）为
$$
F = {[f_1 \quad f_2 \quad f_3 \quad n_1 \quad n_2 \quad n_3]}^T
$$
其中f表示力，n表示扭矩。&lt;/p&gt;
&lt;p&gt;end effector的速度则为
$$
\dot{x} = {[\dot{x}_1 \quad \dot{x}_2 \quad \dots \quad \dot{x}_n]}^T
$$
那么施加在end effector上的外力对整个系统做功的功率即为
$$
P = F^T \dot{x}
$$
由能量守恒定律，我们必须有
$$
P = {\tau}^T \dot{q} = F^T \dot{x}
$$
带入瞬时运动学的式子：
$$
{\tau}^T \dot{q} = F^T \dot{x} \\&lt;br&gt;
\tau^T = F^TJ = (J^TF)^T \\&lt;br&gt;
\tau = J^TF
$$
注：$(AB)^T = B^TA^T$&lt;/p&gt;
&lt;p&gt;经过漫长的推导，我们得到雅可比矩阵的另一个重要用途：J的转置乘以操作空间的力/扭矩就可得到关节空间输出的力/扭矩！这是一个&lt;strong&gt;从操作空间到关节空间的映射&lt;/strong&gt;，与我们之前讲到的正运动学、瞬时运动学方向正好相反。&lt;/p&gt;
&lt;p&gt;应该庆幸，当别人试图把你的手掰到别处时，你的大脑已经把测量你的手受到的外力（F）、计算你手臂的雅可比矩阵的转置、求出每个关节需要输出的力并执行这整个过程，在你完全不知道的情况下完成了。&lt;/p&gt;
&lt;p&gt;那么对于真正的机械臂而言，学习这个力映射关系又有什么意义呢？对于最传统的位置控制机器人，依赖对位置精确的传感，基于一种不达目的地绝不罢休的精神运动，这个式子可能确实没什么用。但是，越来越多的应用场景要求机器人能够在某一位置/某一方向维持特定的力（比如抓握一个物体、擦玻璃）、或者在一个复杂环境中安全工作（保证不会在碰到障碍物时对物体施加过大的作用力）；要实现这样的控制，这个映射关系必不可少——我们以后会更详细地讲解这个式子的应用。&lt;/p&gt;
&lt;h3 id=&#34;2-奇异singularity&#34;&gt;2 奇异（Singularity）&lt;/h3&gt;
&lt;p&gt;我们在《从RP入门机器人学》中提到了Singularity这个问题，简单地说，Singularity就是&lt;strong&gt;机械臂处在某一个configuration（即特定的关节位置组合）时，end effector失去某个方向的自由度&lt;/strong&gt;——你手臂伸直的那一刻，你的手绝无法沿着你手臂的方向运动。&lt;/p&gt;
&lt;p&gt;现在有了雅可比矩阵，我们可以从数学的角度重新来认识Singularity。为什么呢？不要忘了雅可比矩阵的用处：关节的运动速度乘以雅可比矩阵即得到end effector的运动速度。而end effector失去某个方向的自由度即意味着&lt;strong&gt;在机械臂到达那个configuration的瞬间，不管关节怎么运动，end effector在这个方向的速度总为0&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从线性代数的角度来说，此时的J矩阵有这样的特性：对所有任意向量a，$J_a$相乘得到向量b，则所有向量b组成的线性空间维度将比正常情况下少至少一个自由度——这说明什么？说明这个时候的雅可比矩阵&lt;strong&gt;遭遇了降维攻击&lt;/strong&gt;，被&lt;strong&gt;降秩&lt;/strong&gt;了啊！&lt;/p&gt;
&lt;p&gt;我们以RR平面机械臂举例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_07%E9%9B%85%E5%8F%AF%E6%AF%94%E7%9F%A9%E9%98%B5%E7%BB%88%E7%AF%87/7_01RR%E6%9C%BA%E6%A2%B0%E8%87%82.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这个机械臂的雅可比矩阵为：
$$
J = \begin{bmatrix}
\frac{dx_e}{d\theta_1} &amp;amp;  \frac{dx_e}{d\theta_2} \\&lt;br&gt;
\frac{dy_e}{d\theta_1} &amp;amp;  \frac{dy_e}{d\theta_2} 
\end{bmatrix}
= \begin{bmatrix}
-\sin(\theta_1 + \theta_2) - \sin\theta_1 &amp;amp; -\sin(\theta_1 + \theta_2) \\&lt;br&gt;
\cos(\theta_1 + \theta_2) + \cos\theta_1 &amp;amp;  \cos(\theta_1 + \theta_2) 
\end{bmatrix}
$$
现在，为了求出在什么configuration下机械臂会遇到奇异点，即求这个雅可比矩阵什么时候&lt;strong&gt;不是满秩矩阵&lt;/strong&gt;，我们可以直接利用&lt;strong&gt;此时J的特征值为0&lt;/strong&gt;（即此时J是一个奇异矩阵）求得：
$$
det(J) = -\cos(\theta_1 + \theta_2) (\sin(\theta_1 + \theta_2)+\sin\theta_1) + \sin(\theta_1 + \theta_2)(\cos(\theta_1 + \theta_2)+\cos\theta_1) = 0
$$
稍微计算一下（三角恒等式什么的也是要很熟的！）可得：
$$
\sin(\theta_1 + \theta_2)\cos\theta_1 - \cos(\theta_1 + \theta_2)\sin\theta_1 = 0 \\&lt;br&gt;
\sin(\theta_1 + \theta_2 - \theta_1) = \sin\theta_2 = 0
$$
所以singular configuration是$\theta_2=0$！此时，机械臂“伸直”，end effector无法在沿机械臂link的方向上运动。将这个值代入原矩阵，会发现J的行/列向量不是线性独立，它的秩为1。&lt;/p&gt;
&lt;p&gt;在数学上，奇异矩阵的说法只对方阵有效，求特征值也是只对方阵有效。对于机器人来说，（Kinematic）Singularity是机器人在某一个configuration时end effector运动空间的降维，与雅可比矩阵的形状并无关——只是当雅可比矩阵不是方阵时，我们需要先把冗余自由度去掉再求解。&lt;/p&gt;
&lt;h3 id=&#34;3-冗余redundancy&#34;&gt;3 冗余（Redundancy）&lt;/h3&gt;
&lt;p&gt;说到冗余自由度，相信你已经可以想到如何从雅可比矩阵看出冗余了——当它&lt;strong&gt;又矮又胖&lt;/strong&gt;的时候就是啦。在第一篇文章中也曾用你的手举例，因为人的手在关节空间有七个自由度，所以你能够在手部固定的情况下移动你的手肘。从数学的角度上，这意味着
$$
\exists \dot{q},J\dot{q} = 0
$$
不得不感叹数学语言真的是简洁优美……&lt;/p&gt;
&lt;p&gt;我们知道，假如A是一个方阵，那么Ax=0有非零解的充分必要条件是A是一个奇异矩阵——也就是说，如果没有冗余自由度，一个机械臂关节运动而end effector不动的情况只有在它处于singularity时才能出现。但是，如果A是一个矮胖矩阵，那么Ax=0必然有无数个非零解，这些解组成的空间即称为“零空间”（nullspace）。&lt;/p&gt;
&lt;p&gt;简单地提一下：对于一个有冗余自由度的机器人，假设你除了要控制end effector运动到某一位置，还要保证过程中它的手肘不碰到障碍物，那你&lt;strong&gt;总是可以在nullspace中找到一组解满足你的要求&lt;/strong&gt;：在不改变end effector轨迹的同时避开障碍物。这样的方法称为null space control，我们以后有机会会详细展开。&lt;/p&gt;
&lt;p&gt;希望今天这篇文章能让你对雅可比矩阵在机器人学中的重要地位有更强烈的认识，对这个系列一开始提到的机器人的奇异、冗余等问题有更深刻的理解。当然了，希望至少也帮你复习了一下线性代数吧。&lt;/p&gt;
&lt;p&gt;三篇关于雅可比矩阵的文章终于写完了，但是它仍然会不停地出现在以后的文章中——逆运动学、动力学、机器人控制，哪里都有它的影子。在我看来，它是连接机械、物理与数学的桥梁，优美得无与伦比呢。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>【机器人学基础知识】6、机械臂的雅可比矩阵这么厉害，怎么把它求出来呢？</title>
      <link>https://littlethinking.cn/post/robotics/%E5%B9%B2%E8%B4%A7_06%E6%80%8E%E4%B9%88%E6%B1%82%E9%9B%85%E5%8F%AF%E6%AF%94%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Thu, 14 Jan 2021 16:01:23 +0800</pubDate>
      
      <guid>https://littlethinking.cn/post/robotics/%E5%B9%B2%E8%B4%A7_06%E6%80%8E%E4%B9%88%E6%B1%82%E9%9B%85%E5%8F%AF%E6%AF%94%E7%9F%A9%E9%98%B5/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;上一篇文章我们从正运动学公式推导出瞬时运动学公式，推出著名的雅可比矩阵，并例举出了一个特别简单的例子以提供直观印象。简单回顾一下——&lt;/p&gt;
&lt;p&gt;瞬时运动学解决了如何从关节速度得到end effector速度问题:
$$
\dot x = J \dot q
$$
其中，J表示雅可比矩阵（Jacobian Matrix）：
$$
J = \begin{bmatrix}
\frac{dx_1}{dq_1} &amp;amp; \dots &amp;amp; \frac{dx_1}{dq_n} \\&lt;br&gt;
\vdots &amp;amp; \ddots &amp;amp; \vdots \\ 
\frac{dx_m}{dq_1} &amp;amp; \dots &amp;amp; \frac{dx_m}{dq_n} 
\end{bmatrix}
$$
雅可比矩阵的物理意义，以第5行第3列举例来说，&lt;strong&gt;表示当第3个关节转动/平移足够小的一定量（微分概念）时，乘上这个值就等于end effector在第5个自由度上相应的转到/平移量&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1-基本雅可比矩阵basic-jacobian&#34;&gt;1 基本雅可比矩阵（Basic Jacobian）&lt;/h3&gt;
&lt;h4 id=&#34;11-定义&#34;&gt;1.1 定义&lt;/h4&gt;
&lt;p&gt;上面说end effector第5个自由度，到底指的是哪个自由度？显然，这取决于我们如何描述end effector的运动。举个例子来说，假如我们有一个全自由度的end effector (即3个转动DOF，3个平动DOF)，那我们可以&lt;strong&gt;定义前3个自由度为沿某个坐标系（一般指世界/基坐标系）的x,y,z轴平移，后三个自由度为绕该坐标系的x,y,z轴旋转&lt;/strong&gt;——这样我们说的第5个自由度，指的是绕这个坐标系的y轴旋转。实际雅可比矩阵的结果，完全取决于我们选取的坐标系与描述end effector运动的顺序。&lt;/p&gt;
&lt;p&gt;所以，我们把&lt;strong&gt;用笛卡尔坐标系描述线速度(linear velocity)和角速度(angular velocity)、以机械臂的基坐标系(Base frame)或frame {0}作为参考系&lt;/strong&gt;来描述end effector速度所求的雅可比矩阵，称为基本雅可比矩阵；其他所有表示方法(如将笛卡尔坐标系改为柱坐标系、球坐标系；角度改为欧拉角、四元数quaternion等)都可以由这个基本雅可比矩阵转换得到。根据上面基本雅可比矩阵的定义，end effector的速度可以写为：
$$
\dot x = \begin{bmatrix}
v_x \\&lt;br&gt;
v_y \\&lt;br&gt;
v_z \\&lt;br&gt;
w_x \\&lt;br&gt;
w_y \\&lt;br&gt;
w_z
\end{bmatrix}
= \begin{bmatrix}
\vec v \\&lt;br&gt;
\vec w
\end{bmatrix}
$$
相应的，雅可比矩阵也可以写成：
$$
J = \begin{bmatrix}
J_v \\&lt;br&gt;
J_w
\end{bmatrix}
$$
从J的表达式中很容易可以看出，上半部分对应线速度、下半部分对应角速度。&lt;/p&gt;
&lt;h4 id=&#34;12-线速度部分&#34;&gt;1.2 线速度部分&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_06%E6%80%8E%E4%B9%88%E6%B1%82%E9%9B%85%E5%8F%AF%E6%AF%94%E7%9F%A9%E9%98%B5/6_01RR%E6%9C%BA%E6%A2%B0%E8%87%82.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;首先从我们比较容易理解的上半部分$J_v$开始，以之前讲的RR机械臂为例，我们是怎么求出雅可比矩阵的？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;先写出end effector位置的正运动学表达式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
x_e = \cos{(\theta_1 + \theta_2)} + \cos{\theta_1} \\&lt;br&gt;
y_e = \sin{(\theta_1 + \theta_2)} + \sin{\theta_1}
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;再用操作空间的位置向量对关节空间的位置向量求导&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
J = \begin{bmatrix}
\frac{dx_e}{d\theta_1} &amp;amp;  \frac{dx_e}{d\theta_2} \\&lt;br&gt;
\frac{dy_e}{d\theta_1} &amp;amp;  \frac{dy_e}{d\theta_2} 
\end{bmatrix}
= \begin{bmatrix}
-\sin(\theta_1 + \theta_2) - \sin\theta_1 &amp;amp; -\sin(\theta_1 + \theta_2) \\&lt;br&gt;
\cos(\theta_1 + \theta_2) + \cos\theta_1 &amp;amp;  \cos(\theta_1 + \theta_2) 
\end{bmatrix}
$$&lt;/p&gt;
&lt;p&gt;根据瞬时运动学的定义，这个方法是非常直观的。那如果我们的机械臂复杂一点，需要用到齐次坐标变换来求正运动学公式呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_06%E6%80%8E%E4%B9%88%E6%B1%82%E9%9B%85%E5%8F%AF%E6%AF%94%E7%9F%A9%E9%98%B5/6_02RPRR%E6%9C%BA%E6%A2%B0%E8%87%82.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这是我们求出来end effector的正运动学表达式（查看《“正运动学”——从关节空间到操作空间》），这里假设图中$O_e$和$O_4$是重合的：
$$
{}^0_eT = \begin{bmatrix}
× &amp;amp; × &amp;amp; × &amp;amp; l_2c\theta_1c\theta_3 + l_1c\theta_1 \\ 
× &amp;amp; × &amp;amp; × &amp;amp; l_2s\theta_1c\theta_3 + l_1s\theta_1 \\&lt;br&gt;
× &amp;amp; × &amp;amp; × &amp;amp; l_2s\theta_3 + d_2 \\&lt;br&gt;
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1
\end{bmatrix}
$$
由于这里不要旋转矩阵，只需要平移矩阵，我们又假设$O_e$和$O_4$是重合的，则平移矩阵表达的是&lt;strong&gt;end effector的位置w.r.t frame{0}&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以，我们要求的$J_v$，&lt;strong&gt;只需要对平移矩阵对关节空间向量($v_1,d_2,v_3,v_4$)求导即可&lt;/strong&gt;，按照向量求导的规则，我们得到是一个&lt;strong&gt;3 x 4&lt;/strong&gt;的矩阵：
$$
J_v = \begin{bmatrix}
-l_2s\theta_1c\theta_3 - l_1s\theta_1 &amp;amp; 0 &amp;amp; -l_2c\theta_1s\theta_3 &amp;amp; 0 \\&lt;br&gt;
l_2c\theta_1c\theta_3 + l_1c\theta_1 &amp;amp; 0 &amp;amp; -l_2s\theta_1s\theta_3 &amp;amp; 0 \\&lt;br&gt;
0 &amp;amp; 1 &amp;amp; l_2c\theta_3 &amp;amp;0
\end{bmatrix}
$$&lt;/p&gt;
&lt;h4 id=&#34;12-角速度部分&#34;&gt;1.2 角速度部分&lt;/h4&gt;
&lt;p&gt;说完$J_v$，我们要来说下半部分的$J_w$了。这个矩阵其实很容易求，但是要理解它则需要一点小“技巧”。我们还是先从最简单的平面机械臂看起:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_06%E6%80%8E%E4%B9%88%E6%B1%82%E9%9B%85%E5%8F%AF%E6%AF%94%E7%9F%A9%E9%98%B5/6_03RR%E6%9C%BA%E6%A2%B0%E8%87%822.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这次，我们只关心end effector的朝向。对于平面机械臂而言，end effector只有一个转动自由度，即图中标出的α（设与x轴重合时为0°，从x轴旋转到y轴为正方向）。此时我们的操作空间为(&lt;em&gt;α&lt;/em&gt;)，关节空间还是（$\theta_1,\theta_2$);根据定义，我们求解的雅可比矩阵角速度部分如下:
$$
J_{w} = \begin{bmatrix}
\frac{d\alpha}{d\theta_1} &amp;amp; \frac{d\alpha}{d\theta_2} 
\end{bmatrix}
$$
对于这个平面机械臂而言，我们很容易可以看出:$\theta_1$转多少度，$\alpha$就转动多少度；同理$\theta_2$也是。则$J_w$应为[1, 1]。&lt;/p&gt;
&lt;p&gt;举这个例子，希望它能帮助我们建立一个直观印象和基本概念——一个机械臂的旋转关节绕某个轴转多少角度，他的end effector就会相应地绕这个轴多少角度；在平面机械臂的情况中，这表示一个旋转关节的转速&lt;strong&gt;乘以1&lt;/strong&gt;即可得到它引起(Contribute)的end effector转动的速度，因此上面的$J_w$为[1,1]。&lt;/p&gt;
&lt;p&gt;在三维空间里，角速度定义为一个&lt;strong&gt;指向旋转轴的向量&lt;/strong&gt;，其方向可以由右手定则确定。因为我们定义机械臂的每个旋转关节都是&lt;strong&gt;绕自身的Z轴旋转&lt;/strong&gt;的，所以当每一个旋转关节转速为$w$时，它所contribute的end effector的角速度向量以这个旋转关节本身的坐标系为参照系必然为$[0,0,w]$。换句话说，这个旋转关节的转速&lt;strong&gt;乘以[0,0,1]&lt;strong&gt;可以得到它所引起的end effector的角速度(&lt;strong&gt;w.r.t 该旋转关节坐标系&lt;/strong&gt;)。(end effector的实际速度可由不同旋转关节contribute的角速度&lt;/strong&gt;线性叠加&lt;/strong&gt;。)&lt;/p&gt;
&lt;p&gt;由于我们基本的雅可比矩阵是&lt;strong&gt;以frame{0}为参考系&lt;/strong&gt;的，为了写出$J_w$，我们需要把每个旋转关节的z轴[0,0,1]，从以关节自身坐标系为参考系&lt;strong&gt;转换到基准坐标系frame{0}表示&lt;/strong&gt;。另外，对于平移关节，因为&lt;strong&gt;平移关节的运动不可能改变end effector的朝向，故end effector的orientation对平移关节位置的求导一定是0&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;以前面出现的RPRR机械臂为例，它的雅可比矩阵角速度部分是这样的:
$$
J_w = \begin{bmatrix}
{}^0\hat{Z}_1 &amp;amp; \vec{0} &amp;amp; {}^0\hat{Z}_3 &amp;amp; {}^0\hat{Z}_4
\end{bmatrix}
$$
看明白了么?&lt;/p&gt;
&lt;p&gt;现在我们只剩最后一个问题就是怎么把各个关节的z轴坐标w.r.t frame{0}求出来——其实算一遍各个关节的齐次坐标变换矩阵。例如${}^0_1T,{}^0_3T$：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_06%E6%80%8E%E4%B9%88%E6%B1%82%E9%9B%85%E5%8F%AF%E6%AF%94%E7%9F%A9%E9%98%B5/6_04%E5%90%84%E4%B8%AA%E5%85%B3%E8%8A%82%E7%9B%B8%E5%AF%B9%E4%BA%8E%E5%9F%BA%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9A%84%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;13-小结&#34;&gt;1.3 小结&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基本雅可比矩阵的上部分$J_v$由end effector的位置向量对关节求导得出；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;end effector的位置向量可由正运动学得到&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本雅可比矩阵的下半部分$J_w$可由每个旋转关节的z轴以基准坐标系为参考系写出的单位向量得到&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把$J_v$和$J_w$合起来可以得到一个&lt;strong&gt;m × n的矩阵，其中m是end effector/操作空间的自由度（对于空间机械臂通常m=6），n是机械臂的关节数量。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-其它雅可比矩阵&#34;&gt;2 其它雅可比矩阵&lt;/h3&gt;
&lt;p&gt;最后简单地提一下，得到Basic Jacobian 后，要求其他形式的雅可比 矩阵都不是问题，&lt;strong&gt;只需要乘一个转换矩阵就可以了&lt;/strong&gt;。比如说，如果你的end effector位置是由柱坐标表示的，即$(\rho,\theta,z)$,而坐标转换为笛卡尔坐标是:
$$
x = \rho \ \cos{\theta} \\&lt;br&gt;
y = \rho \ \sin{\theta} \\ 
z = z
$$
那么转换矩阵E~p~(这里的p表示position)就&lt;strong&gt;由笛卡尔坐标对柱坐标的向量求导&lt;/strong&gt;得出:&lt;/p&gt;
&lt;p&gt;$$
E_p = \frac
{d\begin{bmatrix}
x \\&lt;br&gt;
y \\ 
z
\end{bmatrix}
}
{d\begin{bmatrix}
\rho \\&lt;br&gt;
\theta \\&lt;br&gt;
z
\end{bmatrix}
}
= \begin{bmatrix}
\cos{\theta} &amp;amp; \sin{\theta} &amp;amp; 0 \\&lt;br&gt;
-\rho\sin{\theta} &amp;amp; \rho\cos{\theta} &amp;amp; 0 \\&lt;br&gt;
0 &amp;amp; 0 &amp;amp; 1
\end{bmatrix}
$$&lt;/p&gt;
&lt;p&gt;而&lt;strong&gt;新的雅可比矩阵的上半部分就等于基本雅可比矩阵的$J_v$左乘上这个$E_p$&lt;/strong&gt;。对于旋转也类似——大家了解一下就好，不再详细展开了。&lt;/p&gt;
&lt;p&gt;这篇文章主要讲了Basic Jacobian的求法，新的内容不多，但希望能够让你对雅可比矩阵有更进一步了解。上次说要讲雅可比矩阵与Singularity、Redundancy的关系，还说要解矮胖的线性方程……篇幅所限，只能留到下一篇了。毕竟雅可比矩阵这么重要，为它多写一篇也不为过呢！&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>【机器人学基础知识】5、“瞬时运动学”——还是从关节空间到操作空间</title>
      <link>https://littlethinking.cn/post/robotics/%E5%B9%B2%E8%B4%A7_05%E7%9E%AC%E6%97%B6%E8%BF%90%E5%8A%A8%E5%AD%A6/</link>
      <pubDate>Wed, 13 Jan 2021 16:01:23 +0800</pubDate>
      
      <guid>https://littlethinking.cn/post/robotics/%E5%B9%B2%E8%B4%A7_05%E7%9E%AC%E6%97%B6%E8%BF%90%E5%8A%A8%E5%AD%A6/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;看懂本文，除了了解矩阵、向量、向量点乘、矩阵向量相乘等内容，以及看明白我们该系列的前四篇文章外，你还需要懂得简单的&lt;strong&gt;向量求导运算&lt;/strong&gt;——其实很简单啦，如果你不知道怎么对向量求导，那就把它当一列标量一个一个写出来，比如这样：
$$
\frac{d\vec{x}}{d\vec{q}} =   \frac
{
d{\begin{bmatrix}
x_1 \\&lt;br&gt;
x_2 \\ 
x_3
\end{bmatrix}
}
}
{
d{\begin{bmatrix}
q_1 \\&lt;br&gt;
q_2
\end{bmatrix}
}
}
= \begin{bmatrix}
\frac{dx_1}{dq_1} &amp;amp; \frac{dx_1}{dq_2} \\&lt;br&gt;
\frac{dx_2}{dq_1} &amp;amp; \frac{dx_2}{dq_2} \\&lt;br&gt;
\frac{dx_3}{dq_1} &amp;amp; \frac{dx_3}{dq_2}
\end{bmatrix}
$$&lt;/p&gt;
&lt;p&gt;不知道行列怎么分布？把分母乘到右边，算一下&lt;strong&gt;左边是3×1向量，右边是3×2矩阵乘以2×1向量 = 3×1向量&lt;/strong&gt;，左右相等，搞定！简单粗暴，方便有效。哎呀，一不小心，把&lt;strong&gt;雅可比矩阵&lt;/strong&gt;（Jacobian Matrix）都给写出来了呢。（想要知道数学上是怎么定义推导出向量求导方法的请去上数学课，我只负责教你记住啦😄）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上一篇文章我们利用&lt;strong&gt;DH参数&lt;/strong&gt;与&lt;strong&gt;坐标变换&lt;/strong&gt;，推到了机械臂的“正运动学”求解方法：只要知道机械臂的结构以及每个关节的位置（关节位置，指的是&lt;strong&gt;旋转关节的角度以及平移关节的平移&lt;/strong&gt;），就可以求出end effector的位置和朝向，即完整的end effector的齐次变换矩阵w.r.t基座/地面坐标系。“正运动学”通常对应“逆运动学”，这篇文章先聚焦“瞬时运动学”；因为它与前面的内容一脉相承，在一类机器人控制的理论框架中，也比逆运动学更重要。&lt;/p&gt;
&lt;p&gt;瞬时运动学（Instantaneous kinematic）也是描述从关节空间到操作空间的映射，“瞬时”表明它不是描述“静态”的文章，而是描述“动态”的&lt;strong&gt;速度&lt;/strong&gt;。还记得正运动学要求解的“函数“是什么吗？如下所示：
$$
\vec{x}=f(\vec{q})
$$
其中，q向量表示关节位置，x向量表示end effector的位置和朝向。&lt;/p&gt;
&lt;p&gt;在上一篇文章的正运动学求解中，由于空间朝向表示的复杂性，我们最终用齐次坐标变换矩阵T来表示end effector的位置和朝向，而不是一个向量。不过，从数学的角度或抽象理解的角度来讲，上面的式子显然更为通用（更何况我们有“一百种”办法可以用向量来表示空间朝向，分分钟抛弃旋转矩阵）。&lt;/p&gt;
&lt;p&gt;现在，当我们说“瞬时运动学”求解的是从关节空间到操作空间的速度映射时，由于速度描述的是短时间内的位置变化，即&lt;strong&gt;位置对时间的导数&lt;/strong&gt;，相信你很自然地会想到我们需要求解这样一个函数：
$$
\frac{d\vec{x}}{dt} = g(\frac{d\vec{q}}{dt}) \\&lt;br&gt;
or \\&lt;br&gt;
\dot{x} = g(\dot{q})
$$
现在我们的任务就是，从“正运动学”公式推导出“瞬时运动学”公式：
$$
\frac{d\vec{x}}{dt} = \frac {df(\vec{q})}{dt}
= \frac {df(\vec{q})}{d\vec{q}} \cdot \frac {d\vec{q}}{dt} \\&lt;br&gt;
i.e: \ \dot{x} =\frac{d\vec{x}}{dq} \cdot \dot{q}
$$
有没有觉得上面的式子某个地方很眼熟啊？没错，就是我们一开始提到的向量x对向量q的求导了！&lt;strong&gt;将关节空间的速度与操作空间的速度连接起来的，就是由向量求导获得的雅可比矩阵。&lt;strong&gt;现在，让我们把这个&lt;/strong&gt;重要的结论&lt;/strong&gt;用数学方式表示出来，用J表示向量x对向量q的导数：
$$
\dot{x} = J\dot{q}
$$
根据一开始讲的向量求导方法，J是一个矩阵。这个矩阵其实一点也不抽象：如果我们仔细看它的每一个元素，就会发现它的&lt;strong&gt;第i行第j列表示的物理意义就是当第j个关节运动时，操作空间的第i个平动/转动方向会如何运动&lt;/strong&gt;：
$$
J = \begin{bmatrix}
\frac{dx_1}{dq_1} &amp;amp; \cdots &amp;amp; \frac{dx_1}{dq_n} \\&lt;br&gt;
\vdots &amp;amp; \ddots &amp;amp; \vdots \\&lt;br&gt;
\frac{dx_m}{dq_1} &amp;amp; \cdots &amp;amp; \frac{dx_m}{dq_n}
\end{bmatrix}
$$
比如第一行第一列，就表示当第一个关节运动某个角度/距离时，end effector相应的在x1这个方向上运动/转动某个距离/角度。如果你还是觉得太抽象，那我们来看一个例子，还是上一篇文章用到的那个平面机械臂：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_05%E7%9E%AC%E6%97%B6%E8%BF%90%E5%8A%A8%E5%AD%A6/5_01RR%E6%9C%BA%E6%A2%B0%E8%87%82.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们的关节空间是$(\theta_1,\theta_2)$，操作空间是$(x_e,y_e)$，我们也写出了正运动学公式（将link的长度都定为1）：
$$
x_e = \cos(\theta_1 + \theta_2) + \cos\theta_1 \\&lt;br&gt;
y_e = \sin(\theta_1 + \theta_2) + \sin\theta_1
$$
那么雅可比矩阵就是:
$$
J = \begin{bmatrix}
\frac{dx_e}{d\theta_1} &amp;amp;  \frac{dx_e}{d\theta_2} \\&lt;br&gt;
\frac{dy_e}{d\theta_1} &amp;amp;  \frac{dy_e}{d\theta_2} 
\end{bmatrix}
= \begin{bmatrix}
-\sin(\theta_1 + \theta_2) - \sin\theta_1 &amp;amp; -\sin(\theta_1 + \theta_2) \\&lt;br&gt;
\cos(\theta_1 + \theta_2) + \cos\theta_1 &amp;amp;  \cos(\theta_1 + \theta_2) 
\end{bmatrix}
$$
注意在我们这个例子中，关节空间有两个自由度、操作空间也有两个自由度，所以我们的雅可比矩阵是正方形的（square matrix）；但&lt;strong&gt;雅可比矩阵不一定是方阵&lt;/strong&gt;，这一点大家要记住。&lt;/p&gt;
&lt;p&gt;如果你考虑一下当$\theta_1$为0， $\theta_2$为90°的时候，代入算一下，我们会得到这样的雅可比矩阵：
$$
J = \begin{bmatrix}
-1 &amp;amp; -1 \\&lt;br&gt;
1 &amp;amp;  0 
\end{bmatrix}
$$
对应的机械臂:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://littlethinking.cn/images/robotics/%E5%B9%B2%E8%B4%A7_05%E7%9E%AC%E6%97%B6%E8%BF%90%E5%8A%A8%E5%AD%A6/5_01RR%E6%9C%BA%E6%A2%B0%E8%87%822.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;现在你看，如果我们保持第一个关节不动、转动第二个关节，那么&lt;strong&gt;在这一个瞬间&lt;/strong&gt;end effector将只能在x方向运动，速度为1（线速度等于角速度乘以半径，即link的长度），y方向的速度则为0，所以J矩阵的第二列是[-1, 0]。&lt;/p&gt;
&lt;p&gt;而如果我们保持第二个关节不动、转动第一个关节，end effector的瞬时速度将与end effector与第一个关节轴的连线垂直，其半径为√2，则线速度为√2，分解为x方向的-1和y方向的1，所以J矩阵的第一列为[-1, 1]。&lt;/p&gt;
&lt;p&gt;希望这么啰嗦的解释可以让你获得雅可比矩阵最直观的理解，一旦理解了，是不是其实很简单呢？&lt;/p&gt;
&lt;p&gt;瞬时运动学的这个公式太优美了，让我们再看一遍：
$$
\dot{x} = J \dot{q}
$$
这个式子表明了，end effector的速度与joint velocity的关系是线性的！这个式子的形式也与我们在线性代数中用尽了各种方法（高斯消元法是其中一种）去求解的线性方程&lt;strong&gt;Ax = b&lt;/strong&gt;一模一样：&lt;strong&gt;如果我们想要end effector以某个速度运动，求对应的关节速度，那这个问题就是一个解线性方程的问题了&lt;/strong&gt;！比起逆运动学，这实在漂亮方便了不知道多少倍呢。&lt;/p&gt;
&lt;p&gt;如果你只知道A矩阵是正方形时怎么解，那么学习机器人学就可以帮助你以最直观的方式了解当A矩阵是瘦高型或者矮胖型的时候是什么意义、又如何求解了——又学机器人学又学线性代数，是不是很超值？下一篇文章，作者会教你如何写出雅可比矩阵，更会带你深入地了解它、应用它（比如我们第一篇干货文就提到的&lt;strong&gt;奇异点Singularity和冗余自由度Redundancy&lt;/strong&gt;，都可以从雅可比矩阵获得数学上的理解），顺便还会教你如何对付高瘦矮胖的线性方程。&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
